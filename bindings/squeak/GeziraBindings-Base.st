Object subclass: #GeziraBindings	instanceVariableNames: 'threads memory commands'	classVariableNames: 'ShowPipeline Threads'	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraBindings methodsFor: 'accessing' stamp: 'bf 6/9/2011 16:23'!appendKernels: anArray	commands		ifNil: [commands := anArray]		ifNotNil: [commands := commands , anArray].! !!GeziraBindings methodsFor: 'accessing' stamp: 'bf 6/9/2011 16:23'!kernels: anArray	commands := anArray.! !!GeziraBindings methodsFor: 'accessing' stamp: 'bf 5/24/2011 15:06'!memory	^memory ifNil: [memory := self memoryDefault]! !!GeziraBindings methodsFor: 'accessing' stamp: 'bf 5/24/2011 15:06'!memory: anInteger	memory := anInteger! !!GeziraBindings methodsFor: 'accessing' stamp: 'bf 6/16/2011 10:23'!memoryDefault	^ 10000000! !!GeziraBindings methodsFor: 'accessing' stamp: 'bf 5/24/2011 15:04'!threads	^threads ifNil: [threads := self threadsDefault]! !!GeziraBindings methodsFor: 'accessing' stamp: 'bf 5/24/2011 15:02'!threads: anInteger	threads := anInteger.! !!GeziraBindings methodsFor: 'accessing' stamp: 'bf 3/9/2012 19:01'!threadsDefault	^Threads ifNil: [self class optimizeNumberOfThreads]! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 9/22/2011 16:08'!applyColorSpansSpans: spansKernel	"Automatically generated (see generateBuilders)"	^ spansKernel, {{#Kernel. #ApplyColorSpans}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 3/17/2011 13:14'!applyTextureT: tKernel	"Automatically generated (see generateBuilders)"	^ tKernel, {{#Kernel. #ApplyTexture}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 3/17/2011 13:14'!bicubicFilterT: tKernel	"Automatically generated (see generateBuilders)"	^ tKernel, {{#Kernel. #BicubicFilter}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 3/17/2011 13:14'!bilinearFilterT: tKernel	"Automatically generated (see generateBuilders)"	^ tKernel, {{#Kernel. #BilinearFilter}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!calculateBounds	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CalculateBounds}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!clipBeziersMinX: minX minY: minY maxX: maxX maxY: maxY	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #ClipBeziers. minX asFloat. minY asFloat. maxX asFloat. maxY asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 9/22/2011 15:49'!colorSpanS1A: s1A s1R: s1R s1G: s1G s1B: s1B s2A: s2A s2R: s2R s2G: s2G s2B: s2B l: l	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #ColorSpan. s1A asFloat. s1R asFloat. s1G asFloat. s1B asFloat. s2A asFloat. s2R asFloat. s2G asFloat. s2B asFloat. l asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeClear	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeClear}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeColorBurn	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeColorBurn}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeColorDodge	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeColorDodge}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeDarken	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeDarken}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeDifference	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeDifference}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeDst	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeDst}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeDstAtop	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeDstAtop}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeDstIn	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeDstIn}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeDstOut	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeDstOut}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeDstOver	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeDstOver}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeExclusion	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeExclusion}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeHardLight	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeHardLight}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeInvert	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeInvert}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeLighten	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeLighten}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeMultiply	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeMultiply}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeOver	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeOver}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeOverlay	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeOverlay}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositePlus	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositePlus}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeScreen	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeScreen}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeSoftLight	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeSoftLight}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeSrc	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeSrc}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeSrcAtop	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeSrcAtop}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeSrcIn	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeSrcIn}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeSrcOut	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeSrcOut}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeSubtract	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeSubtract}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 3/17/2011 13:14'!compositeTexturesT1: t1Kernel t2: t2Kernel c: cKernel	"Automatically generated (see generateBuilders)"	^ t1Kernel, t2Kernel, cKernel, {{#Kernel. #CompositeTextures}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!compositeXor	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #CompositeXor}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!contrastiveOverA: a	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #ContrastiveOver. a asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 3/17/2011 13:14'!gaussianBlur11x1F: f t: tKernel	"Automatically generated (see generateBuilders)"	^ tKernel, {{#Kernel. #GaussianBlur11x1. f asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 3/17/2011 13:14'!gaussianBlur1x11F: f t: tKernel	"Automatically generated (see generateBuilders)"	^ tKernel, {{#Kernel. #GaussianBlur1x11. f asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 3/17/2011 13:14'!gaussianBlur1x21F: f t: tKernel	"Automatically generated (see generateBuilders)"	^ tKernel, {{#Kernel. #GaussianBlur1x21. f asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 3/17/2011 13:14'!gaussianBlur1x5F: f t: tKernel	"Automatically generated (see generateBuilders)"	^ tKernel, {{#Kernel. #GaussianBlur1x5. f asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 3/17/2011 13:14'!gaussianBlur21x1F: f t: tKernel	"Automatically generated (see generateBuilders)"	^ tKernel, {{#Kernel. #GaussianBlur21x1. f asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 3/17/2011 13:14'!gaussianBlur5x1F: f t: tKernel	"Automatically generated (see generateBuilders)"	^ tKernel, {{#Kernel. #GaussianBlur5x1. f asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!inverseOverA: a	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #InverseOver. a asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 11/18/2011 19:08'!linearGradientSX: sX sY: sY eX: eX eY: eY	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #LinearGradient. sX asFloat. sY asFloat. eX asFloat. eY asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 9/22/2011 15:49'!padGradient	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #PadGradient}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 9/22/2011 15:49'!padTextureDX: dX dY: dY	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #PadTexture. dX asFloat. dY asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 9/22/2011 15:49'!radialGradientCX: cX cY: cY r: r	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #RadialGradient. cX asFloat. cY asFloat. r asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 3/17/2011 13:14'!rasterize	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #Rasterize}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 5/20/2011 18:01'!rectangleSpansMinX: minX minY: minY maxX: maxX maxY: maxY	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #RectangleSpans. minX asFloat. minY asFloat. maxX asFloat. maxY asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 9/22/2011 15:49'!reflectGradient	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #ReflectGradient}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 9/22/2011 15:49'!reflectTextureDX: dX dY: dY	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #ReflectTexture. dX asFloat. dY asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 9/22/2011 15:49'!repeatGradient	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #RepeatGradient}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 9/22/2011 15:49'!repeatTextureDX: dX dY: dY	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #RepeatTexture. dX asFloat. dY asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 5/31/2011 19:25'!strokeBezierPathW: w l: l c: c	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #StrokeBezierPath. w asFloat. l asFloat. c asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!transformBeziersMA: mA mB: mB mC: mC mD: mD mE: mE mF: mF	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #TransformBeziers. mA asFloat. mB asFloat. mC asFloat. mD asFloat. mE asFloat. mF asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!transformPointsMA: mA mB: mB mC: mC mD: mD mE: mE mF: mF	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #TransformPoints. mA asFloat. mB asFloat. mC asFloat. mD asFloat. mE asFloat. mF asFloat}}! !!GeziraBindings methodsFor: 'building-generated' stamp: 'bf 1/26/2011 17:34'!uniformColorCA: cA cR: cR cG: cG cB: cB	"Automatically generated (see generateBuilders)"	^ {{#Kernel. #UniformColor. cA asFloat. cR asFloat. cG asFloat. cB asFloat}}! !!GeziraBindings methodsFor: 'building' stamp: 'bf 1/26/2011 17:37'!capture: aFloatArray	^ {{#Kernel. #Capture. aFloatArray}}! !!GeziraBindings methodsFor: 'building' stamp: 'bf 8/13/2010 21:49'!clipBeziers: aRectangle	^self clipBeziersMinX: aRectangle left		minY: aRectangle top		maxX: aRectangle right		maxY: aRectangle bottom! !!GeziraBindings methodsFor: 'building' stamp: 'bf 3/21/2011 18:29'!compositeUniformColorCA: cA cR: cR cG: cG cB: cB overImageARGB32: aForm 	"This is an optimization for				{#Kernel. #UniformColor. cA asFloat. cR asFloat. cG asFloat. cB asFloat}.				{#Kernel. #ReadFromImageARGB32. aForm}.				{#Kernel. #CompositeOver}.			{#Kernel. #CompositeTextures}.		{#Kernel. #ApplyTexture}.		{#Kernel. #WriteToImageARGB32. aForm}.	"	aForm unhibernate.	^ {{#Kernel. #CompositeUniformColorOverImageARGB32. cA asFloat. cR asFloat. cG asFloat. cB asFloat. aForm}}! !!GeziraBindings methodsFor: 'building' stamp: 'bf 6/10/2011 11:34'!feed: vertices	^self feed: vertices from: 1 to: vertices size by: 6! !!GeziraBindings methodsFor: 'building' stamp: 'bf 3/22/2011 19:51'!funnel	^ {{#Kernel. #Funnel}}! !!GeziraBindings methodsFor: 'building' stamp: 'bf 5/24/2011 13:55'!kernels	^commands! !!GeziraBindings methodsFor: 'building' stamp: 'bf 3/21/2011 23:51'!pipeline: anArray	| stream |	stream := (Array new: 100) writeStream.	anArray do: [:cmds | stream nextPutAll: cmds].	stream nextPut: {#Kernel. #Pipeline. anArray size}.	^stream contents! !!GeziraBindings methodsFor: 'building' stamp: 'bf 5/24/2011 14:50'!pour: vertices	^self pour: vertices from: 1 to: vertices size final: true! !!GeziraBindings methodsFor: 'building' stamp: 'bf 3/17/2011 14:02'!pour: vertices from: start to: end final: isLast	commands := commands, {{#Pour. vertices asFloatArray. start. end. isLast}}! !!GeziraBindings methodsFor: 'building' stamp: 'bf 3/17/2011 17:21'!readFromImageARGB32: aForm	aForm unhibernate.	^ {{#Kernel. #ReadFromImageARGB32. aForm}}! !!GeziraBindings methodsFor: 'building' stamp: 'bf 12/15/2011 22:16'!sync	"This concludes a rendering pipeline and starts the rendering, then clears the pipeline"	commands ifNil: [^self].	ShowPipeline == true ifTrue: [Transcript show: self commandsStringPrefix].	"Transcript clear; show: self commandsStringC"	false ifTrue: [			FileStream newFileNamed: (FileDirectory default nextNameFor: self pluginName extension: 'txt')			do: [:f | f nextPutAll: self commandsStringC]].	[	[self primExecuteThreads: self threads		memory: self memory		commands: commands	] on: Error do: [:error |		(error messageText beginsWith: 'Unknown kernel')			ifTrue: [				self beep.				Transcript show: error messageText; space; show: (commands at: self primErrorItem) second; show: ' (EMULATING)'; cr.				(self as: GZBindings) sync]			ifFalse: [				Transcript show: error messageText; show: ' (LOGGED)'; cr.				FileStream newFileNamed: (FileDirectory default nextNameFor: self pluginName extension: 'txt')					do: [:f | f nextPutAll: self commandsStringC].				error pass]].	] ensure: [commands := nil].! !!GeziraBindings methodsFor: 'building' stamp: 'bf 11/11/2011 23:30'!syncIfNeeded	commands size > 1000 ifTrue: [self sync]! !!GeziraBindings methodsFor: 'building' stamp: 'bf 8/13/2010 21:50'!transformBeziers: aMatrix	^self transformBeziersMA: aMatrix a11		mB: aMatrix a21		mC: aMatrix a12		mD: aMatrix a22		mE: aMatrix a13		mF: aMatrix a23! !!GeziraBindings methodsFor: 'building' stamp: 'bf 8/13/2010 21:55'!transformPoints: aMatrix	^self transformPointsMA: aMatrix a11		mB: aMatrix a21		mC: aMatrix a12		mD: aMatrix a22		mE: aMatrix a13		mF: aMatrix a23! !!GeziraBindings methodsFor: 'building' stamp: 'bf 3/17/2011 17:54'!writeToImageARGB32: aForm	aForm unhibernate.	^ {{#Kernel. #WriteToImageARGB32. aForm}}! !!GeziraBindings methodsFor: 'printing' stamp: 'bf 10/17/2011 22:50'!commandsSpecs	| specs |	specs := {		#Funnel -> #().		#ReadFromImageARGB32->#((Form 'f')).		#WriteToImageARGB32->#((Form 'f')).		#CompositeUniformColorOverImageARGB32 -> #((Real 'a') (Real 'r') (Real 'g') (Real 'b') (Form 'f')).		#Capture->#((Array 'a')).	} as: Dictionary. 	self class kernelDefinitionsDo: [:k :d | specs at: k put: d].	^specs! !!GeziraBindings methodsFor: 'printing' stamp: 'bf 10/17/2011 22:51'!commandsStringC	"Return pipeline print string in C notation (for reproducing bugs)"	| specs stack kernel realArgs kernelArgs func crtab |	specs := self commandsSpecs.	crtab := String cr, String tab.	stack := OrderedCollection new.	commands do: [:cmd |		cmd first caseOf: {			[#Kernel] -> [				kernel := cmd second.				realArgs := cmd allButFirst: 2.				kernelArgs := stack removeLast: (kernel = #Pipeline					ifTrue: [realArgs := #(). cmd third]					ifFalse: [(specs at: kernel) count: [:s | s first = #Kernel]]).				func := String streamContents: [:stream |					stream nextPutAll: 'gezira_', kernel, '(init'.					realArgs do: [:a | stream nextPutAll: ', '; print: a].					kernelArgs withIndexDo: [:a :i |						stream nextPutAll: ', '; crtab; nextPutAll: (a copyReplaceAll: String cr with: crtab)].					stream nextPutAll: ')'].				stack addLast: func].			[#Pour] -> [stack add: (String streamContents: [:stream |				stream nextPutAll: 'nile_Funnel_pour(pipe, {'.				cmd second do: [:v | stream print: v] separatedBy: [stream nextPutAll: ', '].				stream nextPutAll: '}, '; print: cmd third - 1.				(cmd allButFirst: 3) do: [:a | stream nextPutAll: ', '; print: a].				stream nextPutAll: ')'.				])].			[#Sync] -> [stack add: 'Sync()'].		}].	^String streamContents: [:s |		s nextPutAll: 'pipe = '.		stack do: [:c | s nextPutAll: c asString; cr]]! !!GeziraBindings methodsFor: 'printing' stamp: 'bf 10/17/2011 22:51'!commandsStringPostfix	"Return pipeline print string in postfix notation (that is, as stack construction calls)"	| specs stack kernel realArgs kernelArgs func lines |	specs := self commandsSpecs.	stack := OrderedCollection new.	commands do: [:cmd |		cmd first caseOf: {			[#Kernel] -> [				kernel := cmd second.				realArgs := cmd allButFirst: 2.				kernelArgs := stack removeLast: (kernel = #Pipeline					ifTrue: [cmd third]					ifFalse: [(specs at: kernel) count: [:s | s first = #Kernel]]).				func := String streamContents: [:stream |					kernelArgs withIndexDo: [:a :ai |						lines := a findTokens: Character cr.						lines withIndexDo: [:l :li |							stream nextPutAll: (li < lines size									ifTrue: [ai = 1 ifTrue: ['	'] ifFalse: ['|	']]									ifFalse: [ai = 1 ifTrue: ['/--'] ifFalse: ['|--']]);								nextPutAll: l; cr]].					stream nextPutAll: kernel, '('.					realArgs do: [:a | stream space; print: (a isFloat ifTrue: [a roundTo: 0.001] ifFalse: [a])].					stream nextPutAll: ' )'].				stack addLast: func].			[#Pour] -> [stack add: (String streamContents: [:stream |				stream nextPutAll: 'Pour([ '.				cmd second do: [:v | stream print: (v roundTo: 0.001); space].				stream nextPutAll: '] '.				(cmd allButFirst: 2) do: [:a | stream print: a; space].				stream nextPutAll: ')'.				])].			[#Sync] -> [stack add: 'Sync()'].		}].	^String streamContents: [:s |		stack do: [:c | s nextPutAll: c asString; cr]]! !!GeziraBindings methodsFor: 'printing' stamp: 'bf 10/17/2011 22:52'!commandsStringPrefix	"Return pipeline print string in prefix notation (that is, like nested function calls)."	| specs stack kernel realArgs kernelArgs func crtab crbartab |	specs := self commandsSpecs.	crtab := String cr, String tab.	crbartab := String cr, '|', String tab.	stack := OrderedCollection new.	commands do: [:cmd |		cmd first caseOf: {			[#Kernel] -> [				kernel := cmd second.				realArgs := cmd allButFirst: 2.				kernelArgs := stack removeLast: (kernel = #Pipeline					ifTrue: [cmd third]					ifFalse: [(specs at: kernel) count: [:s | s first = #Kernel]]).				func := String streamContents: [:stream |					stream nextPutAll: kernel, '('.					realArgs do: [:a | stream space; print: (a isFloat ifTrue: [a roundTo: 0.001] ifFalse: [a])].					kernelArgs withIndexDo: [:a :i |						stream cr; nextPutAll: (i < kernelArgs size ifTrue: ['|--'] ifFalse: ['\--']);							nextPutAll: (a copyReplaceAll: String cr								with: (i < kernelArgs size ifTrue: [crbartab] ifFalse: [crtab]))].					stream nextPutAll: ' )'].				stack addLast: func].			[#Pour] -> [stack add: (String streamContents: [:stream |				stream nextPutAll: 'Pour([ '.				cmd second do: [:v | stream print: (v roundTo: 0.001); space].				stream nextPutAll: '] '.				(cmd allButFirst: 2) do: [:a | stream print: a; space].				stream nextPutAll: ')'.				])].			[#Sync] -> [stack add: 'Sync()'].		}].	^String streamContents: [:s |		stack do: [:c | s nextPutAll: c asString; cr]]! !!GeziraBindings methodsFor: 'primitives' stamp: 'bf 3/17/2011 13:51'!pluginMissing	| moduleName |	moduleName := thisContext sender method literals first first.	(Smalltalk listLoadedModules noneSatisfy: [:each | each beginsWith: moduleName])		ifTrue: [			Smalltalk unloadModule: moduleName.			self error: moduleName, ' plugin not found'.			^true].	^false! !!GeziraBindings methodsFor: 'primitives' stamp: 'bf 6/15/2011 11:23'!pluginName	self class methodsDo: [:method |		method primitive = 117			ifTrue: [^method literals first first]].	^self error: 'no primitives defined'! !!GeziraBindings methodsFor: 'primitives' stamp: 'bf 6/16/2011 10:47'!primErrorCode	"Answer the code returned from nile_error"	<primitive: 'primitiveErrorCode' module: 'GeziraBindingsMT'>	^self primitiveFailed! !!GeziraBindings methodsFor: 'primitives' stamp: 'bf 6/16/2011 10:16'!primErrorItem	"Answer the index of the command causing a primitive failure in the last execute call"	<primitive: 'primitiveErrorItem' module: 'GeziraBindingsMT'>	^self primitiveFailed! !!GeziraBindings methodsFor: 'primitives' stamp: 'bf 6/16/2011 10:16'!primErrorMessage	"Answer a string description for the cause of the primitive failure in the last execute call"	<primitive: 'primitiveErrorMessage' module: 'GeziraBindingsMT'>	^self primitiveFailed! !!GeziraBindings methodsFor: 'primitives' stamp: 'bf 6/16/2011 11:02'!primExecuteThreads: nThreads memory: nBytes commands: pipelineSpec	"This is the only primitive actually invoking Gezira - it executes an Array with commands"	<primitive: 'primitiveExecuteThreadsMemCmds' module: 'GeziraBindingsMT'>	^self pluginMissing ifFalse: [		| item code message command |		item := self primErrorItem.		code := self primErrorCode.		message := self primErrorMessage.		command := (pipelineSpec at: item ifAbsent: [#(Unknown)]) first.		command = #Kernel			ifTrue: [command := (pipelineSpec at: item) second].		self error: message, ' (', command, ': ', code asString, ')']! !!GeziraBindings methodsFor: 'primitives' stamp: 'bf 6/16/2011 10:16'!primNumberOfCores	<primitive: 'primitiveNumberOfCores' module: 'GeziraBindingsMT'>	^self pluginMissing ifFalse: [self primitiveFailed]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GeziraBindings class	instanceVariableNames: ''!!GeziraBindings class methodsFor: 'preferences' stamp: 'bf 3/9/2012 20:59'!benchmarkFor: milliseconds	"GeziraBindings benchmarkFor: 1000"	| f angle offset c frames start |	f := Form extent: 100@100 depth: 32.	c := GeziraCanvas on: f.	c deferRendering: true.	angle := 0.	offset := 50@50.	frames := 0.	start := Time millisecondClockValue.	[(Time millisecondsSince: start) <= milliseconds] whileTrue: [		f fillBlack.		angle := angle + 5 \\ 360.		c preserveTransformDuring: [			c translateBy: offset.			1 to: 500 do: [:i | 				c preserveTransformDuring: [					c color: (Color h: i * 12 s: 1 v: 1).					c rotateBy: i*18.					c translateBy: i*0.1@0.					c scaleBy: 0.1.					c rotateBy: angle.					c drawPath: GeziraCanvas star]].			c rotateBy: angle.			c preserveTransformDuring: [				c color: ((Color h: angle s: 1 v: 1) alpha: 0.7).				c scaleBy: (angle - 180) abs / 300.0 + 0.1.				c drawPath: GeziraCanvas star]].		c flush.		f display.		Display forceToScreen: f boundingBox.		frames := frames + 1.	].	^frames! !!GeziraBindings class methodsFor: 'preferences' stamp: 'bf 3/9/2012 18:31'!cores	^self new primNumberOfCores! !!GeziraBindings class methodsFor: 'preferences' stamp: 'bf 3/12/2012 11:07'!initialize	self threads: nil.! !!GeziraBindings class methodsFor: 'preferences' stamp: 'bf 3/12/2012 11:08'!optimizeNumberOfThreads	"GeziraBindings optimizeNumberOfThreads"	| benchmarks threshold good |	benchmarks := (1 to: self cores) collect: [:threads |		self threads: threads.		(self benchmarkFor: 500) -> threads].	threshold := benchmarks max key * 0.9.	good := ((benchmarks select: [:ea | ea key > threshold]) detectMin: [:ea | ea value]) value.	self threads: good.	^good! !!GeziraBindings class methodsFor: 'preferences' stamp: 'bf 3/9/2012 18:29'!threads: anInteger	"default number of threads to use"	Threads := anInteger.! !!GeziraBindings class methodsFor: 'utilities' stamp: 'bf 6/8/2011 07:52'!downsample: aForm	"return a form half the size of aForm"	| target vertices g t |	aForm extent <= (1@1) ifTrue: [^aForm].	target := Form extent: aForm extent // 2 depth: 32.	t := MatrixTransform2x3 withScale: aForm extent / target extent.	vertices := (0@0 extent: target extent) asGeziraPath.	(g := self new)		kernels: (			g pipeline: {				g funnel.				g rasterize.				g applyTextureT: (					g pipeline: {						g transformPoints: t.						g bilinearFilterT: (							g readFromImageARGB32: aForm)}).				g writeToImageARGB32: target});		pour: vertices from: 1 to: vertices size final: true;		sync.	^target! !!GeziraBindings class methodsFor: 'example' stamp: 'bf 3/22/2011 20:10'!example	"GeziraBindings example"	| target vertices g |	target := Form extent: 400@300 depth: 32.	vertices := GeziraCanvas star.	(g := GeziraBindings new)			kernels: (g pipeline: {				g funnel.				g transformBeziers: (MatrixTransform2x3 withOffset: 150@150).				g clipBeziers: target boundingBox.				g rasterize.				g compositeUniformColorCA: 0.5 cR: 1 cG: 0 cB: 0 overImageARGB32: target });		pour: vertices from: 1 to: vertices size final: true;		sync.	Display getCanvas translucentImage: target at: 0@0! !!GeziraBindings class methodsFor: 'example' stamp: 'bf 6/22/2011 01:37'!exampleBounds	"GeziraBindings exampleBounds"	| bounds vertices g target transform rectangle |	vertices := GeziraCanvas star.	transform := MatrixTransform2x3 withOffset: 150@150.	transform := transform composedWithLocal: (MatrixTransform2x3 withAngle: 20).	"get bounds"	bounds := FloatArray new: 4.	(g := GeziraBindings new)		kernels: (			g pipeline: {				g funnel.				g transformBeziers: transform.				g calculateBounds.				g capture: bounds});		pour: vertices from: 1 to: vertices size final: true;		sync.	target := Form extent: 400@300 depth: 32.	"draw star"	(g := GeziraBindings new)		kernels: (			g pipeline: {				g funnel.				g transformBeziers: transform.				g clipBeziers: target boundingBox.				g rasterize.				g compositeUniformColorCA: 1 cR: 1 cG: 0 cB: 0 overImageARGB32: target});		pour: vertices from: 1 to: vertices size final: true;		sync.	"draw bounds"	rectangle := (bounds first@bounds second corner: bounds third@bounds fourth) asGeziraPath.	(g := GeziraBindings new)		kernels: (			 g pipeline: {				g funnel.				g strokeBezierPathW: 2 l: 4 c: 0.				g clipBeziers: target boundingBox.				g rasterize.				g compositeUniformColorCA: 1 cR: 0 cG: 0 cB: 1 overImageARGB32: target});		pour: rectangle from: 1 to: rectangle size final: true;		sync.	Display getCanvas translucentImage: target at: 0@0.! !!GeziraBindings class methodsFor: 'example' stamp: 'bf 6/8/2011 13:14'!exampleFallingLetters	"GeziraBindings exampleFallingLetters"	| target font scale paths letters scene g em frames start threads color speed transform angle angles m |	target := Form extent: 600@600 depth: 32.	em := 16.	font := TTFontDescription descriptionFullNamed: 'Times New Roman'.	scale := MatrixTransform2x3 withScale: (1 @ -1) * em / font unitsPerEm.	paths := ($a to: $z) collect: [:c | ((font at: c) asGeziraPath transformedBy: scale) floats].	angles := (1 to: 360) collect: [:a |		m := MatrixTransform2x3 withAngle: a.		{m a11. m a21. m a12. m a22}].	g := GeziraBindings new.	"clear target"	g	kernels: (			g pipeline: {				g funnel.				g rectangleSpansMinX: 0 minY: 0 maxX: target width maxY: target height. 				g compositeUniformColorCA: 1 cR: 1 cG: 1 cB: 1 overImageARGB32: target});		pour: FloatArray new.	"render letters, collect transform nodes"	letters := (1 to: 5000) collect: [:i |		color := Color random.		g appendKernels: (			g pipeline: {				g funnel.				transform := g transformBeziers: (MatrixTransform2x3 withOffset: target width atRandom @ target height atRandom).				g clipBeziers: target boundingBox.				g rasterize.				g compositeUniformColorCA: 1 cR: color red cG: color green cB: color blue overImageARGB32: target});			pour: paths atRandom.		{		"1: transform"	transform first.		"2: speed"		20 atRandom * 0.1 + 0.1.		"3: angle"		360 atRandom.		}].	scene := g kernels.	threads := g threadsDefault.	frames := 0.	start := Time millisecondClockValue.	[threads = 0 | Sensor anyButtonPressed] whileFalse: [		"animate"		letters do: [:letter |			transform := letter at: 1.			speed := letter at: 2.			angle := letter at: 3 put: (letter at: 3) + 5 \\ 360.			transform at: 8 put: (transform at: 8) + speed \\ (target height + em). "fall"			1 to: 4 do: [:i |				transform at: i + 2 put: ((angles at: angle + 1) at: i)]].		"render"		g	kernels: scene; 			threads: threads;			sync.		"and show"		Display getCanvas drawImage: target at: 0@0.		"also show fps"		frames := frames + 1.		threads asString, ': ', (frames * 1000 / ((Time millisecondsSince: start) asFloat) roundTo: 0.01) printString, '    ' displayAt: 0@target height.		Sensor peekKeyboardEvent ifNotNilDo: [:e |			e third >= $0 asInteger ifTrue: [				threads := e third - $0 asInteger max: 0].			frames := 0.			start := Time millisecondClockValue]].	Display restore.	^scene! !!GeziraBindings class methodsFor: 'example' stamp: 'bf 11/18/2011 19:11'!exampleGradient	"GeziraBindings exampleGradient"	| target vertices m i g |	target := Form extent: 400@300 depth: 32.	vertices := GeziraCanvas star.	m := MatrixTransform2x3 withOffset: 150@150. 	i := m inverseTransformation.	(g := GeziraBindings new)		kernels: (			g pipeline: {				g funnel.				g transformBeziers: m.				g clipBeziers: target boundingBox.				g rasterize.				g applyTextureT: (					g pipeline: {						g transformPoints: i.						g linearGradientSX: 0.0 sY: -100.0 eX: 0.0 eY: 100.0.						g padGradient.						g applyColorSpansSpans:							(g pipeline: {								g colorSpanS1A: 1.0 s1R: 1.0 s1G: 0.0 s1B: 0.0									s2A: 1.0 s2R: 1.0 s2G: 1.0 s2B: 0.0									l: 0.5. "red->yellow, length 0.5"								g colorSpanS1A: 1.0 s1R: 1.0 s1G: 1.0 s1B: 0.0									s2A: 1.0 s2R: 0.0 s2G: 1.0 s2B: 0.0									l: 0.5. "yellow->green, length 0.5"})}).				g writeToImageARGB32: target});		pour: vertices from: 1 to: vertices size final: true;		sync.	Display getCanvas translucentImage: target at: 0@0! !!GeziraBindings class methodsFor: 'example' stamp: 'bf 9/22/2011 16:20'!exampleGradientRadial	"GeziraBindings exampleGradientRadial"	| target vertices m i g |	target := Form extent: 400@300 depth: 32.	vertices := GeziraCanvas star.	m := MatrixTransform2x3 withOffset: 150@150. 	i := m inverseTransformation.	(g := GeziraBindings new)		kernels: (			g pipeline: {				g funnel.				g transformBeziers: m.				g clipBeziers: target boundingBox.				g rasterize.				g applyTextureT:					(g pipeline: {						g transformPoints: i.						g radialGradientCX: 0.0 cY: 0.0 r: 100.0.						g padGradient.						g applyColorSpansSpans:							(g pipeline: {								g colorSpanS1A: 1.0 s1R: 1.0 s1G: 0.0 s1B: 0.0									s2A: 1.0 s2R: 1.0 s2G: 1.0 s2B: 0.0									l: 0.5. "red->yellow, length 0.5"								g colorSpanS1A: 1.0 s1R: 1.0 s1G: 1.0 s1B: 0.0									s2A: 1.0 s2R: 0.0 s2G: 1.0 s2B: 0.0									l: 0.5. "yellow->green, length 0.5"})}).				g writeToImageARGB32: target});		pour: vertices from: 1 to: vertices size final: true;		sync.	Display getCanvas translucentImage: target at: 0@0! !!GeziraBindings class methodsFor: 'example' stamp: 'bf 10/18/2011 11:35'!exampleJointsCaps	"GeziraBindings exampleJointsCaps"	| target vertices g |	target := Form extent: 600@200 depth: 32.	target fillWhite.	vertices := #(0 0 0 0 30 -50  30 -50 30 -50 60 0).	#(-1 0 1 15) withIndexDo: [:p :x |		1 to: 30 by: 29 do: [:w |			(g := GeziraBindings new)				kernels: (					g pipeline: {						g funnel.						g transformBeziers: (MatrixTransform2x3 withOffset: x@1 * 120).						g strokeBezierPathW: w l: p c: (w = 1 ifTrue: [0] ifFalse: [p]).						g clipBeziers: target boundingBox.						g rasterize.						g compositeUniformColorCA: 0.5 cR: 0 cG: 0 cB: 1 overImageARGB32: target});				pour: vertices asFloatArray from: 1 to: vertices size final: true;				sync]].	Display getCanvas translucentImage: target at: 0@0! !!GeziraBindings class methodsFor: 'example' stamp: 'bf 6/8/2011 14:23'!examplePrim	"Demos what actually gets send to the plugin - it's in postfix notation"	"GeziraBindings examplePrim"	| target vertices |	target := Form extent: 400@300 depth: 32.	vertices := GeziraCanvas star.	GeziraBindings new		primExecuteThreads: 1 memory: 5000000 commands:  {				{#Kernel. #Funnel}.				{#Kernel. #TransformBeziers. 1.0. 0.0. 0.0. 1.0. 150.0. 150.0}.				{#Kernel. #ClipBeziers. 0.0. 0.0. target width asFloat. target height asFloat}.				{#Kernel. #Rasterize}.						{#Kernel. #UniformColor. 0.5. 1.0. 0.0. 0.0}.						{#Kernel. #ReadFromImageARGB32. target}.						{#Kernel. #CompositeOver}.					{#Kernel. #CompositeTextures}.				{#Kernel. #ApplyTexture}.				{#Kernel. #WriteToImageARGB32. target}.			{#Kernel. #Pipeline. 6}.			{#Pour. vertices asFloatArray. 1. vertices size. true}.		}.	Display getCanvas translucentImage: target at: 0@0! !!GeziraBindings class methodsFor: 'example' stamp: 'bf 10/17/2011 20:02'!exampleSoftShadow	"GeziraBindings exampleSoftShadow"	| bounds vertices g target shadowOffset blurWidth blurFlattenFactor transform shadowForm shadowColor boundsPath blurForm |	vertices := GeziraCanvas star.	shadowColor := Color black alpha: 0.5.	shadowOffset := 2@5.	blurWidth := 11.	blurFlattenFactor := 1.	transform := MatrixTransform2x3 withOffset: 150@150.	transform := transform composedWithLocal: (MatrixTransform2x3 withAngle: 20).	"get bounds"	bounds := FloatArray new: 4.	(g := GeziraBindings new)		kernels: (			g pipeline: {				g funnel.				g transformBeziers: transform.				g calculateBounds.				g capture: bounds});		pour: vertices from: 1 to: vertices size final: true;		sync.	bounds := bounds first@bounds second corner: bounds third@bounds fourth.	bounds := bounds expandBy: blurWidth + 1 // 2.	boundsPath := (0@0 extent: bounds extent) asGeziraPath.	"render object into shadow form"	shadowForm := Form extent: bounds extent depth: 32.	(g := GeziraBindings new)		kernels: (			g pipeline: {				g funnel.				g transformBeziers: transform.				g transformBeziers: (MatrixTransform2x3 withOffset: bounds topLeft negated).				g clipBeziers: shadowForm boundingBox.				g rasterize.				g compositeUniformColorCA: shadowColor alpha cR: shadowColor red cG: shadowColor green cB: shadowColor blue overImageARGB32: shadowForm});		pour: vertices from: 1 to: vertices size final: true;		sync.	"blur shadow horizontally"	blurForm := Form extent: bounds extent depth: 32.	(g := GeziraBindings new)		kernels: (			g pipeline: {				g funnel.				g clipBeziers: blurForm boundingBox.				g rasterize.				g applyTextureT: (g gaussianBlur11x1F: blurFlattenFactor t: (					g readFromImageARGB32: shadowForm)).				g writeToImageARGB32: blurForm});		pour: boundsPath from: 1 to: boundsPath size final: true;		sync.	"blur shadow vertically"	(g := GeziraBindings new)		kernels: (			g pipeline: {				g funnel.				g clipBeziers: shadowForm boundingBox.				g rasterize.				g applyTextureT: (g gaussianBlur1x11F: blurFlattenFactor t: (					g readFromImageARGB32: blurForm)).				g writeToImageARGB32: shadowForm});		pour: boundsPath from: 1 to: boundsPath size final: true;		sync.	"draw shadow"	target := Form extent: 400@300 depth: 32.	(g := GeziraBindings new)		kernels: (			g pipeline: {				g funnel.				g transformBeziers: (MatrixTransform2x3 withOffset: bounds topLeft + shadowOffset).				g clipBeziers: target boundingBox.				g rasterize.				g applyTextureT: (g pipeline: {					g transformPoints: (MatrixTransform2x3 withOffset: (bounds topLeft + shadowOffset) negated).					g readFromImageARGB32: shadowForm.				}).				g writeToImageARGB32: target});		pour: boundsPath from: 1 to: boundsPath size final: true;		sync.	"draw object"	(g := GeziraBindings new)		kernels: (g pipeline: {			g funnel.			g transformBeziers: transform.			g clipBeziers: target boundingBox.			g rasterize.			g compositeUniformColorCA: 1 cR: 1 cG: 0 cB: 0 overImageARGB32: target});		pour: vertices from: 1 to: vertices size final: true;		sync.	"show result"	Display getCanvas translucentImage: target at: 0@0.! !!GeziraBindings class methodsFor: 'example' stamp: 'bf 5/31/2011 19:28'!exampleStroking	"GeziraBindings exampleStroking"	| target vertices g |	target := Form extent: 400@300 depth: 32.	vertices := GeziraCanvas star.	(g := GeziraBindings new)		kernels: (			g pipeline: {				g funnel.				g transformBeziers: (MatrixTransform2x3 withOffset: 150@150).				g strokeBezierPathW: 10 l: 4 c: 0.				g clipBeziers: target boundingBox.				g rasterize.				g  compositeUniformColorCA: 1 cR: 0 cG: 0 cB: 1 overImageARGB32: target});		pour: vertices asFloatArray from: 1 to: vertices size final: true;		sync.	Display getCanvas translucentImage: target at: 0@0! !!GeziraBindings class methodsFor: 'definitions' stamp: 'bf 5/20/2011 17:42'!extraKernels	"hand-written (not generated) kernels"	^#('Funnel'		'Pipeline'		'Capture'		'ReadFromImageARGB32'		'WriteToImageARGB32'		'CompositeUniformColorOverImageARGB32')! !!GeziraBindings class methodsFor: 'definitions' stamp: 'bf 11/18/2011 19:01'!kernelDefinitions	"created using kernelDefinitionsFromFile:"^'ApplyColorSpans(Kernel spans)ApplyTexture(Kernel t)BicubicFilter(Kernel t)BilinearFilter(Kernel t)CalculateBounds()ClipBeziers(Real min_x,Real min_y,Real max_x,Real max_y)ColorSpan(Real S1_a,Real S1_r,Real S1_g,Real S1_b,Real S2_a,Real S2_r,Real S2_g,Real S2_b,Real l)CompositeClear()CompositeColorBurn()CompositeColorDodge()CompositeDarken()CompositeDifference()CompositeDst()CompositeDstAtop()CompositeDstIn()CompositeDstOut()CompositeDstOver()CompositeExclusion()CompositeHardLight()CompositeInvert()CompositeLighten()CompositeMultiply()CompositeOver()CompositeOverlay()CompositePlus()CompositeScreen()CompositeSoftLight()CompositeSrc()CompositeSrcAtop()CompositeSrcIn()CompositeSrcOut()CompositeSubtract()CompositeTextures(Kernel t1,Kernel t2,Kernel c)CompositeXor()ContrastiveOver(Real a)GaussianBlur11x1(Real f,Kernel t)GaussianBlur1x11(Real f,Kernel t)GaussianBlur1x21(Real f,Kernel t)GaussianBlur1x5(Real f,Kernel t)GaussianBlur21x1(Real f,Kernel t)GaussianBlur5x1(Real f,Kernel t)InverseOver(Real A)LinearGradient(Real S_x,Real S_y,Real E_x,Real E_y)PadGradient()PadTexture(Real D_x,Real D_y)RadialGradient(Real C_x,Real C_y,Real r)Rasterize()RectangleSpans(Real min_x,Real min_y,Real max_x,Real max_y)ReflectGradient()ReflectTexture(Real D_x,Real D_y)RepeatGradient()RepeatTexture(Real D_x,Real D_y)StrokeBezierPath(Real w,Real l,Real c)TransformBeziers(Real M_a,Real M_b,Real M_c,Real M_d,Real M_e,Real M_f)TransformPoints(Real M_a,Real M_b,Real M_c,Real M_d,Real M_e,Real M_f)UniformColor(Real C_a,Real C_r,Real C_g,Real C_b)'! !!GeziraBindings class methodsFor: 'definitions' stamp: 'yo 5/13/2011 15:25'!kernelDefinitions2Do: aBlock	"self kernelDefinitionsDo: [:kernel :args | Transcript cr; show: kernel, ': ', args asString; cr]"	| s kernel arguments |	s := self kernelDefinitions readStream.	[s atEnd] whileFalse: [		kernel := (s upTo: $() withBlanksTrimmed.		arguments := ((s upTo: $)) findTokens: ',') asArray			collect: [:arg | 				{(arg copyUpToLast: Character space) withBlanksTrimmed.				(arg copyAfterLast: Character space)}].		aBlock value: kernel value: arguments].! !!GeziraBindings class methodsFor: 'definitions' stamp: 'bf 8/13/2010 13:24'!kernelDefinitionsDo: aBlock	"self kernelDefinitionsDo: [:kernel :args | Transcript cr; show: kernel, ': ', args asString; cr]"	| s kernel arguments |	s := self kernelDefinitions readStream.	[s atEnd] whileFalse: [		kernel := (s upTo: $() withBlanksTrimmed.		arguments := ((s upTo: $)) findTokens: ',') asArray			collect: [:arg | 				{(arg copyUpToLast: Character space) withBlanksTrimmed.				((arg copyAfterLast: Character space) copyReplaceAll: '_' with: ' ')					withFirstCharacterDownshifted toCamelCase}].		aBlock value: kernel value: arguments].! !!GeziraBindings class methodsFor: 'definitions' stamp: 'bf 9/22/2011 16:07'!systemKernels	"These kernels are only used internally, not exposed in the bindings"	^#(		'BicubicFilterDeltas'		'BicubicFilterPoints'		'BicubicFilterWeights'		'BilinearFilterPoints'		'BilinearFilterWeights'		'CapBezier'		'ColorSpansBegin'		'ColorSpansEnd'		'CombineEdgeSamples'		'DecomposeBeziers'		'ExtractSamplePoints'		'ExpandSpans'		'GaussianBlur5x1Points'		'GaussianBlur1x5Points'		'GaussianBlur5x1Weights'		'GaussianBlur11x1Points'		'GaussianBlur1x11Points'		'GaussianBlur11x1Weights'		'GaussianBlur21x1Points'		'GaussianBlur1x21Points'		'GaussianBlur21x1Weights'		'JoinBeziers'		'MiterJoin'		'OffsetAndJoin'		'OffsetBezier'		'ReverseBeziers'		'RoundJoin'		'SanitizeBezierPath'		'StrokeOneSide'		'SumWeightedColors')! !!GeziraBindings class methodsFor: 'generating' stamp: 'bf 6/24/2011 17:16'!generateAll	"self generateAll"	self generateBuilders."	self generateMBuilders."	self generatePluginDispatch.	self generatePluginKernels.! !!GeziraBindings class methodsFor: 'generating' stamp: 'bf 1/26/2011 17:33'!generateBuilders	"self generateBuilders"	| firstArg type arg kernels params |	self kernelDefinitionsDo: [:kernel :argDefs |		self in: #GeziraBindings			classified: 'building-generated'			compile: (String streamContents: [:stream |				stream nextPutAll: kernel withFirstCharacterDownshifted.				firstArg := true.				kernels := OrderedCollection new.				params := OrderedCollection new.				argDefs do: [:argDef |					type := argDef first.					arg := argDef second.					firstArg ifTrue: [						stream nextPutAll: arg capitalized, ': ', arg.						firstArg := false.					] ifFalse: [						stream nextPutAll: ' ', arg, ': ', arg					].					type = 'Kernel'						ifTrue: [kernels add: arg.							stream nextPutAll: 'Kernel']						ifFalse: [params add: arg]].				stream crtab; nextPutAll: '"Automatically generated (see generateBuilders)"'.				stream crtab; nextPutAll: '^ '.				kernels do: [:k |					stream nextPutAll: k; nextPutAll: 'Kernel, '].				stream nextPutAll: '{{#Kernel. #', kernel.				params do: [:p |					stream nextPutAll: '. '; nextPutAll: p; nextPutAll: ' asFloat'].				stream nextPutAll: '}}'.				])]! !!GeziraBindings class methodsFor: 'generating' stamp: 'bf 1/11/2011 13:00'!generateMBuilders	"self generateMBuilders"	| firstArg type arg kernels params |	self kernelDefinitionsDo: [:kernel :argDefs |		self in: #MGezira			classified: 'building-generated'			compile: (String streamContents: [:stream |				stream nextPutAll: kernel withFirstCharacterDownshifted.				firstArg := true.				kernels := OrderedCollection new.				params := OrderedCollection new.				argDefs do: [:argDef |					type := argDef first.					arg := argDef second.					firstArg ifTrue: [						stream nextPutAll: arg capitalized, ': ', arg.						firstArg := false.					] ifFalse: [						stream nextPutAll: ' ', arg, ': ', arg					].					type = 'Kernel'						ifTrue: [kernels add: arg.							stream nextPutAll: 'Kernel']						ifFalse: [params add: arg]].				stream crtab; nextPutAll: '"Automatically generated (see generateMBuilders)"'.				stream crtab; nextPutAll: '^ '.				kernels do: [:k |					stream nextPutAll: k; nextPutAll: 'Kernel, '].				stream nextPutAll: '{{#Kernel. #', kernel.				params do: [:p |					stream nextPutAll: '. '; nextPutAll: p; nextPutAll: ' asFloat'].				stream nextPutAll: '}}'.				])]! !!GeziraBindings class methodsFor: 'generating' stamp: 'bf 11/18/2011 19:05'!generatePluginDispatch	"self generatePluginDispatch"	| kernels |	kernels := self extraKernels asOrderedCollection.	self kernelDefinitionsDo:		[:kernel :argDefs | kernels add: kernel].	self in: #GeziraBindingsMTPlugin		classified: 'generated'		compile: (String streamContents: [:stream |			stream				nextPutAll: 'dispatchKernel: kernelName size: kernelNameSize arguments: argOops size: argCount';				crtab; nextPutAll: '"Automatically generated (see generatePluginDispatch)"';				crtab; nextPutAll: 'self returnTypeC: ''void''.';				crtab; nextPutAll: 'self var: #argOops type: ''sqInt*''.';				crtab; nextPutAll: 'self var: #kernelName type: ''char*''.'.			kernels do: [:k |				stream crtab; nextPutAll: '(self string: ''', k, ''' equals: kernelName len: kernelNameSize)';					crtab: 2; nextPutAll: 'ifTrue: [^self kernel', k, ': argOops size: argCount].'].			stream crtab; nextPutAll: 'self fail: ''Unknown kernel'''		])! !!GeziraBindings class methodsFor: 'generating' stamp: 'bf 11/18/2011 19:05'!generatePluginKernels	"self generatePluginKernels"	| kernels params type arg |	self kernelDefinitionsDo: [:kernel :argDefs |		self in: #GeziraBindingsMTPlugin			classified: 'generated'			compile: (String streamContents: [:stream |				stream nextPutAll: 'kernel', kernel, ': argOops size: argCount';					crtab; nextPutAll: '"Automatically generated (see generatePluginKernels)"';					crtab; nextPutAll: '| result' .				kernels := OrderedCollection new.				params := OrderedCollection new.				argDefs do: [:argDef |					type := argDef first.					arg := argDef second.					(type = 'Kernel' ifTrue: [kernels] ifFalse: [params])						add: arg.					stream space; nextPutAll: arg].				stream nextPutAll: ' |';					crtab; nextPutAll: 'self returnTypeC: ''void''.';					crtab; nextPutAll: 'self var: #argOops type: ''sqInt*''.';					crtab; nextPutAll: 'self var: #result type: ''nile_Process_t*''.'. 				argDefs do: [:argDef |					stream crtab; nextPutAll: 'self var: #', argDef second, ' type: ''';						nextPutAll: (argDef first = 'Kernel'							ifTrue: ['nile_Process_t*']							ifFalse: ['float']);						nextPutAll: '''.'].				stream crtab; nextPutAll: 'argCount ~= '; print: params size;					crtab: 2; nextPutAll: 'ifTrue: [^self fail: ''wrong argument count in ', kernel, '''].'.				kernels reverseDo: [:k |					stream crtab; nextPutAll: k, ' := self popKernel.'].				params withIndexDo: [:p :i |					stream crtab; nextPutAll: p, ' := interpreterProxy floatValueOf: (argOops at: ', (i-1) asString, ').'].				argDefs ifNotEmpty: [					stream crtab; nextPutAll: 'interpreterProxy failed ifTrue: [^self fail: ''wrong arguments to ', kernel, '''].'].				stream crtab; nextPutAll: 'result := self cCode: ''gezira_', kernel, '(init'.				argDefs do: [:argDef | stream nextPutAll: ', ', argDef second].				stream nextPutAll: ')''.';					crtab; nextPutAll: 'self pushKernel: result.'; cr				])]! !!GeziraBindings class methodsFor: 'generating' stamp: 'bf 1/11/2011 13:02'!in: aClassName classified: aCategory compile: aString	"Compile aString in aCategory of aClass, but only if it is different from the current source code.	Useful to avoid cluttering the changes file when auto-generating methods."	| targetClass selector |	targetClass := Smalltalk classNamed: aClassName.	targetClass ifNil: [^self].	selector := targetClass parserClass new parseSelector: aString.	((targetClass includesSelector: selector)		and: [(targetClass sourceCodeAt: selector) = aString])			ifFalse: [targetClass compile: aString classified: aCategory]! !!GeziraBindings class methodsFor: 'parsing' stamp: 'bf 9/22/2011 16:07'!kernelDefinitionsFromFile: aFileName	"parses gezira.h but excludes systemKernels"	"Clipboard clipboardText: (self kernelDefinitionsFromFile: 'vm/src/plugins/GeziraBindingsMT/gezira/c/gezira.h')"	| in l parens sorted exclude |	parens := {$( -> 1. ${ -> 1. $} -> -1. $) -> -1. $; -> -1} as: Dictionary.	in := FileStream readOnlyFileNamed: aFileName.	in wantsLineEndConversion: true.	exclude := self systemKernels asSet.	sorted := SortedCollection new.	[ 		[(l := in nextLine) notNil] whileTrue: [			(l isEmpty or: [l first = $#]) ifFalse: [				[(l inject: 1 into: [:p :c | p + (parens at: c ifAbsent: [0])]) = 0]					whileFalse: [l := l, in nextLine withBlanksTrimmed].							(l beginsWith: 'nile_Process_t *gezira_') ifFalse: [self error: 'parsing failed'].				l := l allButFirst: 23.				l := l allButLast.				#(' (' '(' 'nile_Process_t *p,' '' 'nile_Process_t *p' '' 'float v_' 'Real ' 'nile_Process_t *v_' 'Kernel ')					pairsDo: [:find :replace | l := l copyReplaceAll: find with: replace].				exclude remove: (l copyUpTo: $()					ifAbsent: [sorted add: l].			]		]	] ensure: [in close].	exclude ifNotEmpty: [exclude inspect].	^ String streamContents: [:out | 		sorted do: [:each | out nextPutAll: each; cr]]! !!GeziraBindings class methodsFor: 'debugging' stamp: 'bf 10/15/2010 23:49'!showPipeline: aBoolean	"log rendering pipeline to transcript"	ShowPipeline := aBoolean! !Object subclass: #GeziraCanvas	instanceVariableNames: 'previousState target clipAndTrans fill stroke deferredRenderer'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraCanvas methodsFor: 'converting' stamp: 'bf 9/23/2010 14:14'!asShadowCanvas	^GeziraShadowCanvas new		copyFrom: self;		saveState! !!GeziraCanvas methodsFor: 'accessing' stamp: 'bf 8/26/2010 18:58'!clip	^clipAndTrans first isRectangle		ifTrue: [clipAndTrans first]		ifFalse: [clipAndTrans first globalBoundsToLocal: clipAndTrans second]! !!GeziraCanvas methodsFor: 'accessing' stamp: 'bf 8/26/2010 13:43'!color: aColor	self fill: aColor asGeziraFill! !!GeziraCanvas methodsFor: 'accessing' stamp: 'bf 8/6/2010 11:11'!fill: aGeziraFill	fill := aGeziraFill! !!GeziraCanvas methodsFor: 'accessing' stamp: 'bf 8/26/2010 17:33'!inverseTransformation	^self transform inverseTransformation! !!GeziraCanvas methodsFor: 'accessing' stamp: 'bf 8/20/2010 15:25'!stroke: aStrokeOrNil	stroke := aStrokeOrNil! !!GeziraCanvas methodsFor: 'accessing' stamp: 'bf 8/26/2010 18:14'!transform	| t |	t := nil.	clipAndTrans reverseDo: [:each | each isRectangle ifFalse: [		t := t ifNil: [each] ifNotNil: [t composedWithLocal: each]]].	^t ifNil: [MatrixTransform2x3 identity]! !!GeziraCanvas methodsFor: 'clipping' stamp: 'bf 12/13/2011 12:26'!clipBy: aRectangle	| current |	(current := clipAndTrans at: 1) isRectangle		ifTrue: [clipAndTrans at: 1 put: (current clippedBy: aRectangle)]		ifFalse: [			current isPureTranslation				ifTrue: [clipAndTrans at: 2					put: ((clipAndTrans at: 2) clippedBy: (aRectangle translateBy: current offset))]				ifFalse: [					current isAxisAligning						ifTrue: [clipAndTrans at: 2							put: ((clipAndTrans at: 2) clippedBy: (Rectangle encompassing:								{current localPointToGlobal: aRectangle origin.								 current localPointToGlobal: aRectangle corner}))]						ifFalse: [clipAndTrans addFirst: (self clip clippedBy: aRectangle)]]].! !!GeziraCanvas methodsFor: 'clipping' stamp: 'yo 5/25/2011 11:04'!isClipCoveredBy: aRectangle	^ aRectangle containsRect: self clip.! !!GeziraCanvas methodsFor: 'clipping' stamp: 'bf 8/26/2010 17:05'!isFullyVisible: aRectangle	^self clip containsRect: aRectangle! !!GeziraCanvas methodsFor: 'clipping' stamp: 'bf 8/26/2010 17:08'!isVisible: aRectangle	^self clip intersects: aRectangle! !!GeziraCanvas methodsFor: 'deferred rendering' stamp: 'bf 6/9/2011 16:15'!deferRendering: aBoolean	"If true, accumulate drawing commands in deferredRenderer until set to false"	aBoolean		ifTrue: [deferredRenderer ifNil: [			deferredRenderer := GeziraBindings new]]		ifFalse: [			self flush.			deferredRenderer := nil]! !!GeziraCanvas methodsFor: 'deferred rendering' stamp: 'bf 6/9/2011 09:41'!flush	deferredRenderer ifNotNil: [deferredRenderer sync]! !!GeziraCanvas methodsFor: 'drawing' stamp: 'bf 9/30/2010 18:19'!draw: anObject	^anObject drawOn: self! !!GeziraCanvas methodsFor: 'drawing' stamp: 'bf 8/26/2010 23:06'!drawOval: aRectangle	self drawPath: (GeziraPath oval: aRectangle)! !!GeziraCanvas methodsFor: 'drawing' stamp: 'bf 10/17/2011 22:17'!drawPath: aPath	"If we have a deferred renderer, append this path to its commands. Otherwise, render immediately and sync."	| g |	(g := deferredRenderer ifNil: [GeziraBindings new])		appendKernels: (			g pipeline: (				{g funnel}			),(				stroke ifNil: [#()]					ifNotNil: [stroke strokePipelineOn: g]			),(				clipAndTrans collect: [:each |					each isRectangle						ifTrue: [g clipBeziers: each]						ifFalse: [g transformBeziers: each]]			),(				fill renderOn: g target: target for: self			));		pour: aPath from: 1 to: aPath size final: true.	deferredRenderer		ifNil: [g sync]		ifNotNil: [g syncIfNeeded].! !!GeziraCanvas methodsFor: 'drawing' stamp: 'bf 8/26/2010 23:08'!drawPolygon: aPointArray	self drawPath: (GeziraPath polygon: aPointArray)! !!GeziraCanvas methodsFor: 'drawing' stamp: 'bf 8/20/2010 17:30'!drawRectangle: aRectangle	self drawPath: aRectangle asGeziraPath! !!GeziraCanvas methodsFor: 'drawing' stamp: 'bf 8/26/2010 23:10'!drawRectangle: aRectangle radius: aNumber	self drawPath: (GeziraPath rect: aRectangle radius: aNumber)! !!GeziraCanvas methodsFor: 'drawing' stamp: 'yo 7/1/2011 09:31'!resumeDrawing	(target isArray) ifTrue: [ target := target at: 1. ^true ].	^false! !!GeziraCanvas methodsFor: 'drawing' stamp: 'yo 7/1/2011 09:31'!suspendDrawing	(target isArray) ifFalse: [ target := Array with: target. ^true ].	^false! !!GeziraCanvas methodsFor: 'old protocol' stamp: 'bf 8/31/2010 16:22'!fillOval: aRectangle	self drawPath: (GeziraPath oval: aRectangle)! !!GeziraCanvas methodsFor: 'old protocol' stamp: 'bf 8/31/2010 16:23'!fillPolygon: aPointArray	self drawPath: (GeziraPath polygon: aPointArray)! !!GeziraCanvas methodsFor: 'old protocol' stamp: 'bf 8/31/2010 16:23'!fillRectangle: aRectangle	self drawPath: aRectangle asGeziraPath! !!GeziraCanvas methodsFor: 'old protocol' stamp: 'bf 8/26/2010 23:06'!frameOval: aRectangle width: aWidth	self strokePath: (GeziraPath oval: aRectangle) width: aWidth! !!GeziraCanvas methodsFor: 'old protocol' stamp: 'bf 8/26/2010 23:09'!framePolygon: aPointArray width: aNumber	self strokePath: (GeziraPath polygon: aPointArray) width: aNumber! !!GeziraCanvas methodsFor: 'old protocol' stamp: 'bf 8/31/2010 16:23'!strokePath: aPath width: aWidth	stroke := GeziraStroke width: aWidth.	self drawPath: aPath.	stroke := nil.! !!GeziraCanvas methodsFor: 'effects' stamp: 'bf 5/31/2011 23:16'!gaussianBlur11x11: aPath flatten: flattenFactor	| tempForm g |	"blur target horizontally to temp form, 	then blur temp form vertically back on target"	tempForm := Form extent: target extent depth: 32.	(g := GeziraBindings new)		kernels: (			g pipeline: {				g funnel.				g rectangleSpansMinX: 0 minY: 0 maxX: tempForm width maxY: tempForm height.				g applyTextureT: (					g gaussianBlur11x1F: flattenFactor t: (						g readFromImageARGB32: target)).				g writeToImageARGB32: tempForm});		pour: FloatArray new; "trigger rectangleSpans"		sync;	"finish writing to temp form"		kernels: (			g pipeline: {				g funnel.				g rectangleSpansMinX: 0 minY: 0 maxX: target width maxY: target height.				g applyTextureT: (					g gaussianBlur1x11F: flattenFactor t: (						g readFromImageARGB32: tempForm)).				g writeToImageARGB32: target});		pour: FloatArray new; "trigger rectangleSpans"		sync.! !!GeziraCanvas methodsFor: 'effects' stamp: 'bf 5/31/2011 23:16'!gaussianBlur21x21: aPath flatten: flattenFactor	| tempForm g |	"blur target horizontally to temp form, 	then blur temp form vertically back on target"	tempForm := Form extent: target extent depth: 32.	(g := GeziraBindings new)		kernels: (			g pipeline: {				g funnel.				g rectangleSpansMinX: 0 minY: 0 maxX: tempForm width maxY: tempForm height.				g applyTextureT: (					g gaussianBlur21x1F: flattenFactor t: (						g readFromImageARGB32: target)).				g writeToImageARGB32: tempForm});		pour: FloatArray new; "trigger rectangleSpans"		sync;	"finish writing to temp form"		kernels: (			g pipeline: {				g funnel.				g rectangleSpansMinX: 0 minY: 0 maxX: target width maxY: target height.				g applyTextureT: (					g gaussianBlur1x21F: flattenFactor t: (						g readFromImageARGB32: tempForm)).				g writeToImageARGB32: target});		pour: FloatArray new; "trigger rectangleSpans"		sync.! !!GeziraCanvas methodsFor: 'effects' stamp: 'bf 5/31/2011 22:46'!gaussianBlur5x5: aPath flatten: flattenFactor	| tempForm g |	"blur target horizontally to temp form, 	then blur temp form vertically back on target"	tempForm := Form extent: target extent depth: 32.	(g := GeziraBindings new)		kernels: (			g pipeline: {				g funnel.				g rectangleSpansMinX: 0 minY: 0 maxX: tempForm width maxY: tempForm height.				g applyTextureT: (					g gaussianBlur5x1F: flattenFactor t: (						g readFromImageARGB32: target)).				g writeToImageARGB32: tempForm});		pour: FloatArray new; "trigger rectangleSpans"		sync;	"finish writing to temp form"		kernels: (			g pipeline: {				g funnel.				g rectangleSpansMinX: 0 minY: 0 maxX: target width maxY: target height.				g applyTextureT: (					g gaussianBlur1x5F: flattenFactor t: (						g readFromImageARGB32: tempForm)).				g writeToImageARGB32: target});		pour: FloatArray new; "trigger rectangleSpans"		sync.! !!GeziraCanvas methodsFor: 'effects' stamp: 'bf 9/23/2010 11:52'!gaussianBlur: aPath size: blurSize flatten: flattenFactor	blurSize >= 21		ifTrue: [^self gaussianBlur21x21: aPath flatten: flattenFactor].	blurSize >= 11		ifTrue: [^self gaussianBlur11x11: aPath flatten: flattenFactor].	blurSize >= 5		ifTrue: [^self gaussianBlur5x5: aPath flatten: flattenFactor].! !!GeziraCanvas methodsFor: 'testing' stamp: 'bf 9/23/2010 14:15'!isShadowCanvas	^false! !!GeziraCanvas methodsFor: 'preserve state' stamp: 'bf 2/5/2010 15:04'!preserveStateDuring: aBlock	self saveState.	^aBlock ensure: [self restoreState].! !!GeziraCanvas methodsFor: 'preserve state' stamp: 'bf 8/26/2010 18:16'!preserveTransformDuring: aBlock	| old |	old := clipAndTrans copy.	^aBlock ensure: [clipAndTrans := old].! !!GeziraCanvas methodsFor: 'preserve state' stamp: 'bf 8/26/2010 17:05'!restoreState	"Restore the state from the internal stack"	self copyFrom: previousState.! !!GeziraCanvas methodsFor: 'preserve state' stamp: 'bf 8/26/2010 18:15'!saveState	"Save the state of the canvas onto the internal stack."	previousState := self clone.	clipAndTrans := clipAndTrans copy.! !!GeziraCanvas methodsFor: 'transforming' stamp: 'bf 2/5/2010 15:56'!rotateBy: angle	^self transformBy: (MatrixTransform2x3 withAngle: angle)! !!GeziraCanvas methodsFor: 'transforming' stamp: 'bf 2/5/2010 15:57'!scaleBy: scale	^self transformBy: (MatrixTransform2x3 withScale: scale)! !!GeziraCanvas methodsFor: 'transforming' stamp: 'bf 8/26/2010 18:37'!transformBy: aTransform	| prev |	aTransform isIdentity ifTrue: [^self].	(prev := clipAndTrans first) isRectangle		ifTrue: [clipAndTrans addFirst: aTransform]		ifFalse: [clipAndTrans at: 1 put: (prev composedWithLocal: aTransform)].! !!GeziraCanvas methodsFor: 'transforming' stamp: 'bf 2/5/2010 16:32'!translateBy: offset	^self transformBy: (MatrixTransform2x3 withOffset: offset)! !!GeziraCanvas methodsFor: 'initialize-release' stamp: 'bf 9/2/2010 17:35'!setTarget: aForm	target := aForm.	clipAndTrans := OrderedCollection with: target boundingBox.	self color: Color white.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GeziraCanvas class	instanceVariableNames: ''!!GeziraCanvas class methodsFor: 'examples' stamp: 'bf 8/20/2010 17:33'!example1	"GeziraCanvas example1"	| f |	f := Form extent: 500@500 depth: 32.	(GeziraCanvas on: f)		color: (Color red alpha: 0.5);		translateBy: 100@100;		drawPath: self star.	Display getCanvas		translucentImage: f at: 0@0;		forceToScreen: f boundingBox.! !!GeziraCanvas class methodsFor: 'examples' stamp: 'bf 8/20/2010 17:33'!example2	"GeziraCanvas example2"	| f angle offset c |	"Smalltalk unloadModule: 'GeziraBindings'."	f := Form extent: 500@500 depth: 32.	c := GeziraCanvas on: f.	angle := 0.	offset := 250@250.	[Sensor anyButtonPressed] whileFalse: [		f fillBlack.		angle := angle + 5 \\ 360.		c preserveTransformDuring: [			c translateBy: offset.			1 to: 10 do: [:i | 				c preserveTransformDuring: [					c color: (Color h: i * 36 s: 1 v: 1).					c rotateBy: i*36.					c translateBy: 100@0.					c scaleBy: 0.2.					c rotateBy: angle.					c drawPath: self star]].			c rotateBy: angle.			c preserveTransformDuring: [				c color: ((Color h: angle s: 1 v: 1) alpha: 0.5).				c scaleBy: (angle - 180) abs / 100.0 + 0.1.				c drawPath: self star]].		f display.		Display forceToScreen: f boundingBox.		"Sensor waitClickButton."	].	Display restore! !!GeziraCanvas class methodsFor: 'examples' stamp: 'bf 8/20/2010 17:34'!example3	"GeziraCanvas example3"	| f angle offset c frames time |	"Smalltalk unloadModule: 'GeziraBindings'."	f := Form extent: 500@500 depth: 32.	c := GeziraCanvas on: f.	angle := 0.	offset := 250@250.	frames := 0.	time := Time millisecondClockValue.	[Sensor anyButtonPressed] whileFalse: [		f fillWhite.		angle := angle + 5 \\ 360.		c preserveTransformDuring: [			c translateBy: offset.			1 to: 10 do: [:i | 				c preserveTransformDuring: [					c color: ((Color h: i * 36 s: 1 v: 1) alpha: 0.5).					c rotateBy: i*36.					c translateBy: 100@0.					c scaleBy: 0.2.					c rotateBy: angle.					c drawPath: self star]].			c rotateBy: angle.			c preserveTransformDuring: [				c color: ((Color h: angle s: 1 v: 1) alpha: 0.5).				c scaleBy: (angle - 180) abs / 100.0 + 0.1.				c drawPath: self star]].		f display.		Display forceToScreen: f boundingBox.		"Sensor waitClickButton."		frames := frames + 1.		(frames * 1000 / ((Time millisecondsSince: time) asFloat) roundTo: 0.01) printString, '    ' displayAt: 0@600.	].	Display restore! !!GeziraCanvas class methodsFor: 'examples' stamp: 'bf 8/20/2010 17:37'!example4	"GeziraCanvas example4"	| f |	f := Form extent: 500@500 depth: 32.	(GeziraCanvas on: f)		fill: (GeziraFillLinearGradient new			direction: 50@0 offset: 0.5;			addStop: Color blue at: 0;			"-infinity to 0"			addStop: Color red at: 0.01;			addStop: Color yellow at: 0.99;			addStop: Color green at: 1);		"1 to infinity"		translateBy: 100@100;		rotateBy: 10;		scaleBy: 0.75;		drawPath: self star.	Display getCanvas		translucentImage: f at: 0@0;		forceToScreen: f boundingBox.! !!GeziraCanvas class methodsFor: 'examples' stamp: 'bf 8/24/2010 18:48'!example5	"GeziraCanvas example5"	| f |	f := Form extent: 500@500 depth: 32.	(GeziraCanvas on: f)		translateBy: 100@100;		rotateBy: 0;		scaleBy: 0.75;		fill: (GeziraFillRadialGradient new			center: 0@0 radius: 200;			addStop: Color red at: 0;			addStop: Color yellow at: 1);		drawRectangle: (20@20 extent: 200@200) radius: 20;		fill: (GeziraFillLinearGradient new			direction: 200@200 offset: 0;			addStop: Color white at: 0;			addStop: Color black at: 1);		stroke: (GeziraStroke width: 6 joints: GeziraStroke miter caps: GeziraStroke miter);		drawRectangle: (20@20 extent: 200@200) radius: 20.	Display getCanvas		translucentImage: f at: 0@0;		forceToScreen: f boundingBox.! !!GeziraCanvas class methodsFor: 'examples' stamp: 'bf 7/22/2011 17:13'!star	^#(0.0 -100.0 -12.3435 -66.98936 -24.68699 -33.97872 -24.68699 -33.97872 -59.89632 -32.44021 -95.10566 -30.9017 -95.10566 -30.9017 -67.52502 -8.9615 -39.94438 12.97870999999998 -39.94438 12.97870999999998 -49.36145 46.9402 -58.77853 80.90169 -58.77853 80.90169 -29.38927 61.45084 0.0 42.0 0.0 42.0 29.38925999999998 61.45084 58.77852 80.90169 58.77852 80.90169 49.36144 46.9402 39.94437 12.97870999999998 39.94437 12.97870999999998 67.52501 -8.9615 95.10565 -30.9017 95.10565 -30.9017 59.89631 -32.44021 24.68698 -33.97872 24.68698 -33.97872 12.34348999999997 -66.98936 0.0 -100.0) asFloatArray! !!GeziraCanvas class methodsFor: 'instance creation' stamp: 'bf 11/21/2012 00:43'!on: aForm	^self new setTarget: aForm! !Object subclass: #GeziraFill	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraFill methodsFor: 'converting' stamp: 'sw 12/6/2010 13:10'!asColor	^Color transparent! !!GeziraFill methodsFor: 'converting' stamp: 'sw 12/6/2010 13:10'!asGeziraFill	^self! !!GeziraFill methodsFor: 'queries' stamp: 'sw 10/12/2010 14:39'!fillStyle	"Answer a symbol characterizing the style of fill.  This should by rights be reimplemented in each of the GeziraFill subclasses, but in order to minimize contamination of the Gezira classes, the work is currently handled by a single method.  Nonmodular but expedient..."	^ LFillStyleType fillStyleForFill: self! !!GeziraFill methodsFor: 'testing' stamp: 'bf 9/2/2010 17:46'!isOpaque	^false! !!GeziraFill methodsFor: 'testing' stamp: 'bf 8/18/2010 19:15'!isTransparent	^false! !!GeziraFill methodsFor: 'testing' stamp: 'bf 6/27/2012 15:30'!isUniform	^false! !!GeziraFill methodsFor: 'mixing' stamp: 'bf 8/18/2010 18:59'!mixed: proportion with: other	^GeziraFillMix new		setFirst: self second: other proportion: proportion! !!GeziraFill methodsFor: 'rendering' stamp: 'bf 1/26/2011 17:57'!pipelineOn: g for: aCanvas	self subclassResponsibility! !!GeziraFill methodsFor: 'rendering' stamp: 'bf 10/17/2011 20:28'!renderOn: g target: targetForm for: aCanvas	^{		g rasterize.		g applyTextureT: (self isOpaque			ifTrue: [self pipelineOn: g for: aCanvas]			ifFalse: [				g compositeTexturesT1: (self pipelineOn: g for: aCanvas)					t2: (g readFromImageARGB32: targetForm)					c: g compositeOver]).		g writeToImageARGB32: targetForm	}! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GeziraFill class	instanceVariableNames: ''!!GeziraFill class methodsFor: 'instance creation' stamp: 'bf 9/20/2010 18:26'!contrastiveOver: amount	^GeziraFillContrastiveOver new amount: amount! !!GeziraFill class methodsFor: 'instance creation' stamp: 'bf 8/26/2010 21:21'!gradient: anArray center: aPoint radius: aNumber	^GeziraFillRadialGradient new		center: aPoint radius: aNumber;		stops: anArray! !!GeziraFill class methodsFor: 'instance creation' stamp: 'bf 8/26/2010 21:23'!gradient: anArray direction: aPoint offset: aNumber	^GeziraFillLinearGradient new		direction: aPoint offset: aNumber;		stops: anArray! !!GeziraFill class methodsFor: 'instance creation' stamp: 'bf 10/15/2010 23:37'!gradient: anArray from: startPoint to: endPoint	^GeziraFillLinearGradient new		from: startPoint to: endPoint;		stops: anArray! !!GeziraFill class methodsFor: 'instance creation' stamp: 'bf 8/18/2010 18:23'!image: aForm	^ GeziraFillImage new		setForm: aForm! !!GeziraFill class methodsFor: 'instance creation' stamp: 'bf 7/17/2012 15:36'!image: aForm scale: aNumber	^ (self image: aForm)		transform: (MatrixTransform2x3 withScale: aNumber)! !!GeziraFill class methodsFor: 'instance creation' stamp: 'bf 9/9/2010 17:19'!inverseOver: fraction	^GeziraFillInverseOver new fraction: fraction! !!GeziraFill class methodsFor: 'instance creation' stamp: 'bf 8/18/2010 17:44'!transparent	^ GeziraFillNone new! !!GeziraFill class methodsFor: 'instance creation' stamp: 'bf 8/18/2010 17:57'!uniform: aColor	^ GeziraFillUniform new		setAlpha: aColor alpha		red: aColor red		green: aColor green		blue: aColor blue! !!GeziraFill class methodsFor: 'defaults' stamp: 'sw 10/12/2010 14:44'!default	"Answer a default fill instance of a fill class; subclasses reimplement to provide appropriate outfitting of the instance."	^ self new! !!GeziraFill class methodsFor: 'defaults' stamp: 'sw 10/12/2010 14:43'!defaultFillReplacing: aFill	"Answer a default value to use as a fill of this type, given that a previous fill may be in place.  This mechanism has not been properly elaborated yet, and may be superceded by a policy of remembering entire fills in properties so if the style is called upon again, the earlier setting will not be lost..."	^ self default! !GeziraFill subclass: #GeziraFillContrastiveOver	instanceVariableNames: 'fraction amount'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraFillContrastiveOver methodsFor: 'accessing' stamp: 'bf 9/20/2010 18:25'!amount: aFloat	amount := aFloat asFloat! !!GeziraFillContrastiveOver methodsFor: 'rendering' stamp: 'bf 4/8/2011 20:40'!renderOn: g target: targetForm for: aCanvas	^{		g rasterize.		g applyTextureT: 			(g pipeline: {				g readFromImageARGB32: targetForm.				g contrastiveOverA: amount}).		g writeToImageARGB32: targetForm	}! !GeziraFill subclass: #GeziraFillGradient	instanceVariableNames: 'stops'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraFillGradient methodsFor: 'accessing' stamp: 'bf 8/23/2010 16:18'!addStop: aColor at: position	self stops add: position asFloat -> aColor asFloatArray! !!GeziraFillGradient methodsFor: 'accessing' stamp: 'bf 9/15/2011 15:44'!asColor	^ Color fromArray: stops first value! !!GeziraFillGradient methodsFor: 'accessing' stamp: 'bf 8/23/2010 16:13'!stops	^stops ifNil: [stops := SortedCollection new].! !!GeziraFillGradient methodsFor: 'accessing' stamp: 'bf 8/23/2010 16:55'!stops: aCollection	stops := SortedCollection new.	aCollection do: [:each | self addStop: each value at: each key].! !!GeziraFillGradient methodsFor: 'testing' stamp: 'bf 9/2/2010 17:41'!isOpaque	^stops allSatisfy: [:ea | ea value last = 1.0]! !!GeziraFillGradient methodsFor: 'testing' stamp: 'bf 8/23/2010 17:43'!isTransparent	^stops allSatisfy: [:ea | ea value last isZero]! !!GeziraFillGradient methodsFor: 'mixing' stamp: 'tk 10/17/2011 15:36'!maxGreenStop	"Return the greenest of the stops.  If all have the same green, return the color green."		| maxGreen mgEntry |	maxGreen := stops inject: 0 into: [:green :assoc | 			(assoc value at: 2) max: green].	mgEntry := (stops detect: [:assoc | (assoc value at: 2) = maxGreen] 					ifNone: [ ^ Color green]) value.	^ Color r: (mgEntry at: 1) g: (mgEntry at: 2) b: (mgEntry at: 3) 					alpha: (mgEntry at: 4).! !!GeziraFillGradient methodsFor: 'mixing' stamp: 'tk 10/17/2011 15:37'!maxRedStop	"Return the redest of the stops.  If all have the same red, return the color red."		| maxRed mrEntry |	maxRed := stops inject: 0 into: [:red :assoc | 			(assoc value at: 1) max: red].	mrEntry := (stops detect: [:assoc | (assoc value at: 2) = maxRed] 					ifNone: [^ Color red]) value.	^ Color r: (mrEntry at: 1) g: (mrEntry at: 2) b: (mrEntry at: 3) 					alpha: (mrEntry at: 4).! !!GeziraFillGradient methodsFor: 'mixing' stamp: 'tk 10/17/2011 13:37'!solidGreenish	"Return a color for button rollover that is the greenest of the stops.  If all have the same green, return the solid green."		| maxGreen |	^ (maxGreen := self maxGreenStop) ~= self maxRedStop		ifTrue: [maxGreen]		ifFalse: [Color green]! !!GeziraFillGradient methodsFor: 'mixing' stamp: 'tk 10/17/2011 13:37'!solidRedish	"Return a color for button rollover that is the redest of the stops.  If all have the same red, return the solid red."		| maxRed |	^ (maxRed := self maxRedStop) ~= self maxGreenStop		ifTrue: [maxRed]		ifFalse: [Color red]! !!GeziraFillGradient methodsFor: 'rendering' stamp: 'bf 10/17/2011 18:24'!stopsPipelineOn: g	stops size < 2 ifTrue: [^self error: 'too few stops'].	^g pipeline: (		(2 to: stops size) collect: [:i |			| prev next l s1 s2 |			prev := stops at: i - 1.			next := stops at: i.			l := next key - prev key.			s1 := prev value.			s2 := next value.			g colorSpanS1A: s1 fourth s1R: s1 first s1G: s1 second s1B: s1 third				s2A: s2 fourth s2R: s2 first s2G: s2 second s2B: s2 third				l: l])! !GeziraFill subclass: #GeziraFillImage	instanceVariableNames: 'form opaque filter mipmaps transform'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraFillImage methodsFor: 'accessing' stamp: 'bf 9/2/2010 17:49'!beOpaque	opaque := true! !!GeziraFillImage methodsFor: 'accessing' stamp: 'bf 8/18/2010 18:21'!form	^form! !!GeziraFillImage methodsFor: 'accessing' stamp: 'bf 7/27/2011 16:25'!noFiltering	filter := false! !!GeziraFillImage methodsFor: 'accessing' stamp: 'bf 10/25/2010 19:15'!setForm: aForm	form := aForm depth < 32		ifTrue: [(aForm asFormOfDepth: 32)fixAlpha]		ifFalse: [aForm].	opaque := false.	mipmaps := nil.! !!GeziraFillImage methodsFor: 'accessing' stamp: 'bf 7/17/2012 16:55'!transform: aMatrix2x3	"transform texture coordinates by this matrix. That is, a scale by 2 will result in a texture half the size"	transform := aMatrix2x3! !!GeziraFillImage methodsFor: 'accessing' stamp: 'bf 7/17/2012 16:53'!transformedExtent	^transform		ifNil: [form extent]		ifNotNil: [form extent / (transform transformDirection: 1@1)]! !!GeziraFillImage methodsFor: 'testing' stamp: 'bf 9/2/2010 17:48'!isOpaque	^opaque == true! !!GeziraFillImage methodsFor: 'rendering' stamp: 'bf 7/17/2012 15:40'!pipelineOn: g for: aCanvas	| t noFilter f minification level |	t := aCanvas inverseTransformation.	transform ifNotNil: [t := transform composedWithLocal: t].	f := form.	noFilter := filter == false or: [t isPureTranslation and: [t offset = t offset rounded]].	noFilter ifTrue: [		^g pipeline: {			g transformPoints: t.			g readFromImageARGB32: f.		}].	level := 2.	minification := (t a11 @ t a12) r.	[minification > level and: [f extent > (1@1)]] whileTrue: [		mipmaps ifNil: [mipmaps := Dictionary new].					f := mipmaps at: level ifAbsentPut: [GeziraBindings downsample: f].		t a11: t a11 * 0.5.		t a12: t a12 * 0.5.		t a21: t a21 * 0.5.		t a22: t a22 * 0.5.		t a13: t a13 * 0.5.		t a23: t a23 * 0.5.		level := level * 2].	^g pipeline: {		g transformPoints: t.		g bilinearFilterT: (g readFromImageARGB32: f)}! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GeziraFillImage class	instanceVariableNames: ''!!GeziraFillImage class methodsFor: 'defaults' stamp: 'sw 10/20/2010 16:04'!default	"Answer a default image."	^ self image: (ScriptingSystem formAtKey: #Image) ! !GeziraFill subclass: #GeziraFillInverseOver	instanceVariableNames: 'fraction'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraFillInverseOver methodsFor: 'accessing' stamp: 'bf 9/9/2010 17:32'!fraction: aFloat	fraction := aFloat asFloat! !!GeziraFillInverseOver methodsFor: 'rendering' stamp: 'bf 3/23/2011 23:15'!pipelineOn: g target: targetForm for: aCanvas	^g pipeline: {		g readFromImageARGB32: targetForm.		g inverseOverA: fraction}! !GeziraFillGradient subclass: #GeziraFillLinearGradient	instanceVariableNames: 'delta offset from to'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraFillLinearGradient methodsFor: 'accessing' stamp: 'bf 11/18/2011 19:28'!direction	"Deprecated, use from/to instead"	from ifNil: [self fromTo].	^ to - from! !!GeziraFillLinearGradient methodsFor: 'accessing' stamp: 'bf 11/18/2011 19:29'!direction: aPoint	"Deprecated, use from/to instead"	self direction: aPoint offset: offset! !!GeziraFillLinearGradient methodsFor: 'accessing' stamp: 'bf 11/18/2011 19:29'!direction: aPoint offset: zeroToOne	"Deprecated, use from/to instead"	delta := aPoint / (aPoint dotProduct: aPoint) asFloat.	offset := zeroToOne asFloat.! !!GeziraFillLinearGradient methodsFor: 'accessing' stamp: 'bf 11/18/2011 19:29'!fillInOldArgs	"Calculate old delta and offset from new from/to. Should go away ASAP"	| gradientVector gradientLength distanceFromOrigin |	gradientVector := to - from.	gradientLength := gradientVector r.	distanceFromOrigin := from dotProduct: (gradientVector / gradientLength).	self direction: gradientVector		offset: distanceFromOrigin negated / gradientLength! !!GeziraFillLinearGradient methodsFor: 'accessing' stamp: 'bf 11/18/2011 19:20'!from: startPoint to: endPoint	from := startPoint.	to := endPoint.! !!GeziraFillLinearGradient methodsFor: 'accessing' stamp: 'bf 11/18/2011 19:40'!fromTo	| distanceFromOrigin gradientLength gradientVector |	from ifNil: [		"infer to/from based on deprecated delta/offset"		gradientVector := delta * ((1.0 / delta r) raisedTo: 2).		gradientLength := gradientVector r.		distanceFromOrigin := offset * gradientLength negated.		from := (gradientVector / gradientLength) * distanceFromOrigin.		to := from + gradientVector.		from := from roundTo: 0.000001@0.000001.		to := to roundTo: 0.000001@0.000001].	^ {from. to}! !!GeziraFillLinearGradient methodsFor: 'accessing' stamp: 'bf 11/18/2011 19:28'!offset	"Deprecated, use from/to instead"	offset ifNil: [self fillInOldArgs].	^ offset! !!GeziraFillLinearGradient methodsFor: 'accessing' stamp: 'bf 11/18/2011 19:28'!offset: zeroToOne	"Deprecated, use from/to instead"	offset := zeroToOne asFloat! !!GeziraFillLinearGradient methodsFor: 'rendering' stamp: 'bf 11/18/2011 19:16'!pipelineOn: g for: aCanvas	from ifNil: [self fromTo].	^g pipeline: {		g transformPoints: aCanvas inverseTransformation.		g linearGradientSX: from x sY: from y eX: to x eY: to y.		g padGradient.		g applyColorSpansSpans: (self stopsPipelineOn: g)}! !!GeziraFillLinearGradient methodsFor: 'rendering' stamp: 'bf 11/18/2011 19:31'!printOn: aStream	from ifNil: [self fromTo].	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: from printString;		nextPutAll: ', ';		nextPutAll: to printString;		nextPut: $).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GeziraFillLinearGradient class	instanceVariableNames: ''!!GeziraFillLinearGradient class methodsFor: 'defaults' stamp: 'sw 9/1/2010 21:42'!default	"Answer a default fill of the receiver, itself a fill class."	^ self new		direction: 50@0 offset: 0.5;		addStop: Color white at: 0;		addStop: Color blue at: 0.5;		addStop: Color black at: 1;		yourself! !!GeziraFillLinearGradient class methodsFor: 'defaults' stamp: 'sw 10/12/2010 14:48'!defaultFillReplacing: aFill	"Answer a default value to use as a fill of this type, given that a previous fill may be in place.  If replacing a linear fill, an effort is made to have one of the gradient's stop colors be the color of that uniform fill."	| gradientFill |	gradientFill := self new.	gradientFill direction: (50 @ 0) offset: 0.5.	(aFill isKindOf: GeziraFillGradient)		ifTrue:			[gradientFill stops: aFill stops]		ifFalse:			[(aFill isKindOf: GeziraFillUniform)				ifTrue:					[gradientFill addStop: aFill asColor at: 0.01]				ifFalse:					[gradientFill addStop: Color red at: 0.01].			gradientFill addStop: Color white at: 0.5.			gradientFill addStop: Color blue at: 0.99].	^ gradientFill! !GeziraFill subclass: #GeziraFillMix	instanceVariableNames: 'first second proportion'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraFillMix methodsFor: 'testing' stamp: 'bf 9/2/2010 17:42'!isOpaque	^first isOpaque and: [second isOpaque]! !!GeziraFillMix methodsFor: 'testing' stamp: 'bf 9/2/2010 17:42'!isTransparent	^first isTransparent and: [second isTransparent]! !!GeziraFillMix methodsFor: 'rendering' stamp: 'bf 3/17/2011 17:52'!pipelineOn: g for: aCanvas	^g compositeTexturesT1: (first pipelineOn: g for: aCanvas)		t2: (second pipelineOn: g for: aCanvas)		c: g compositeOver! !!GeziraFillMix methodsFor: 'accessing' stamp: 'bf 8/18/2010 18:58'!setFirst: firstFill second: secondFill proportion: aFloat	first := firstFill.	second := secondFill.	proportion := aFloat.! !GeziraFill subclass: #GeziraFillNone	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraFillNone methodsFor: 'testing' stamp: 'bf 8/18/2010 19:15'!isTransparent	^true! !!GeziraFillNone methodsFor: 'rendering' stamp: 'bf 1/26/2011 18:03'!pipelineOn: g for: aCanvas	^g uniformColorCA: 0.0 cR: 0.0 cG: 0.0 cB: 0.0! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GeziraFillNone class	instanceVariableNames: ''!!GeziraFillNone class methodsFor: 'defaults' stamp: 'sw 9/1/2010 21:45'!default	"Answer a default fill of the receiver, itself a fill class."	^ GeziraFill transparent! !GeziraFillGradient subclass: #GeziraFillRadialGradient	instanceVariableNames: 'center radius'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraFillRadialGradient methodsFor: 'accessing' stamp: 'sw 10/12/2010 13:42'!center	"Answer the receiver's center."	^ center! !!GeziraFillRadialGradient methodsFor: 'accessing' stamp: 'sw 10/13/2010 17:12'!center: aPoint	"Set the receiver's center."	self center: aPoint radius: radius! !!GeziraFillRadialGradient methodsFor: 'accessing' stamp: 'bf 8/20/2010 17:43'!center: aPoint radius: aNumber	center := aPoint.	radius := aNumber.! !!GeziraFillRadialGradient methodsFor: 'accessing' stamp: 'yo 9/19/2011 22:44'!fromTo	^ {center. center + (1.0@0 * radius)}! !!GeziraFillRadialGradient methodsFor: 'accessing' stamp: 'sw 10/12/2010 15:03'!radius	"Answer the radius of the radial gradient."	^ radius! !!GeziraFillRadialGradient methodsFor: 'accessing' stamp: 'sw 10/12/2010 15:05'!radius: aNumber	"Set the radius."	self center: center radius: aNumber asNumber! !!GeziraFillRadialGradient methodsFor: 'rendering' stamp: 'bf 10/17/2011 19:14'!pipelineOn: g for: aCanvas	^g pipeline: {		g transformPoints: aCanvas inverseTransformation.		g radialGradientCX: center x cY: center y r: radius.		g padGradient.		g applyColorSpansSpans: (self stopsPipelineOn: g)}! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GeziraFillRadialGradient class	instanceVariableNames: ''!!GeziraFillRadialGradient class methodsFor: 'defaults' stamp: 'sw 9/1/2010 21:53'!default	"Answer a default fill of the receiver, itself a fill class."	^ self new		center: 0@0 radius: 200;		addStop: Color red at: 0;		addStop: Color yellow at: 1;		yourself! !!GeziraFillRadialGradient class methodsFor: 'defaults' stamp: 'sw 10/22/2010 01:48'!defaultFillReplacing: aFill	"Answer a default value to use as a fill of this type, given that a previous fill may be in place.  If replacing a radial fill, an effort is made to have one of the gradient's stop colors be the color of that uniform fill."	| gradientFill |	gradientFill := self new.	gradientFill center: 0@0 radius: 200.	(aFill isKindOf: GeziraFillGradient)		ifTrue:			[gradientFill stops: aFill stops]		ifFalse:			[(aFill isKindOf: GeziraFillUniform)				ifTrue:					[gradientFill addStop: aFill asColor at: 0.01]				ifFalse:					[gradientFill addStop: Color red at: 0.01].			gradientFill addStop: Color white at: 0.5.			gradientFill addStop: Color blue at: 0.99].	^ gradientFill! !GeziraFill subclass: #GeziraFillUniform	instanceVariableNames: 'alpha red green blue'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraFillUniform methodsFor: 'accessing' stamp: 'bf 8/18/2010 18:17'!alpha	^alpha! !!GeziraFillUniform methodsFor: 'accessing' stamp: 'bf 8/18/2010 18:17'!blue	^blue! !!GeziraFillUniform methodsFor: 'accessing' stamp: 'bf 8/18/2010 18:17'!green	^green! !!GeziraFillUniform methodsFor: 'accessing' stamp: 'bf 8/18/2010 18:17'!red	^red! !!GeziraFillUniform methodsFor: 'accessing' stamp: 'bf 8/5/2010 17:06'!setAlpha: a red: r green: g blue: b	alpha := a asFloat.	red := r asFloat.	green := g asFloat.	blue := b asFloat.! !!GeziraFillUniform methodsFor: 'converting' stamp: 'sw 12/6/2010 13:14'!asColor	^Color r: red g: green b: blue alpha: alpha! !!GeziraFillUniform methodsFor: 'testing' stamp: 'bf 9/2/2010 17:45'!isOpaque	^alpha = 1.0! !!GeziraFillUniform methodsFor: 'testing' stamp: 'bf 8/18/2010 19:16'!isTransparent	^alpha isZero! !!GeziraFillUniform methodsFor: 'testing' stamp: 'bf 6/27/2012 15:31'!isUniform	^true! !!GeziraFillUniform methodsFor: 'mixing' stamp: 'bf 8/18/2010 19:12'!mixed: proportion with: other	| frac1 frac2 |	other class == self class		ifFalse: [^super mixed: proportion with: other].	frac1 := proportion asFloat min: 1.0 max: 0.0.	frac2 := 1.0 - frac1.	^ self class new		setAlpha: alpha * frac1 + (other alpha * frac2)		red: red * frac1 + (other red * frac2)		green: green * frac1 + (other green * frac2)		blue: blue * frac1 + (other blue * frac2)! !!GeziraFillUniform methodsFor: 'rendering' stamp: 'bf 1/26/2011 18:04'!pipelineOn: g for: aCanvas	^g uniformColorCA: alpha cR: red cG: green cB: blue! !!GeziraFillUniform methodsFor: 'rendering' stamp: 'yo 10/13/2011 19:00'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(;		nextPutAll: self asColor printString;		nextPut: $)	! !!GeziraFillUniform methodsFor: 'rendering' stamp: 'bf 3/22/2011 19:02'!renderOn: g target: targetForm for: aCanvas	^{ g rasterize.		g compositeUniformColorCA: alpha cR: red cG: green cB: blue overImageARGB32: targetForm }! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GeziraFillUniform class	instanceVariableNames: ''!!GeziraFillUniform class methodsFor: 'defaults' stamp: 'sw 9/1/2010 21:44'!default	"Answer a default fill of the receiver, itself a fill class."	^ self uniform: Color cyan lighter! !!GeziraFillUniform class methodsFor: 'defaults' stamp: 'sw 10/25/2010 15:30'!defaultFillReplacing: aFill	"Answer a default value to use as a fill of this type, given that a previous fill may be in place.  This mechanism has not been properly elaborated yet, and may be superceded by a policy of remembering entire fills in properties so if the style is called upon again, the earlier settings will not be lost..."	(aFill isKindOf: self) ifTrue:		[^ self uniform: aFill asColor].	(aFill isKindOf: GeziraFillGradient) ifTrue:		[^ self uniform: (Color colorFrom: aFill stops first value)].	^ self default! !Object subclass: #GeziraPath	instanceVariableNames: 'floats points'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraPath commentStamp: 'bf 2/18/2010 21:45' prior: 0!Holds either a flat FloatArray suitable for rendering using the GeziraBindings plugin, or an array of contours suitable for rendering using balloon. Also converts between both.!!GeziraPath methodsFor: 'converting' stamp: 'bf 9/1/2010 16:58'!, aPath	self floats: ((floats isNil and: [points isNil])		ifTrue: [aPath asGeziraPath floats]		ifFalse: [self floats, aPath asGeziraPath floats])! !!GeziraPath methodsFor: 'converting' stamp: 'yo 8/29/2012 20:42'!asClosedPath	"Add a line segment from last to first point if they are not identical. This is only correct if this path has a single contour. For multiple contours, use the more expensive #withClosedContours."	| s x0 y0 x1 y1 |	s := self floats size.	s = 0 ifTrue: [^self].	x0 := floats at: 1.	y0 := floats at: 2.	x1 := floats at: s-1.	y1 := floats at: s.	^ (x0 = x1 and: [y0 = y1])		ifTrue: [self]		ifFalse: [self clone			floats: (self floats, {x1. y1. x1. y1. x0. y0})].! !!GeziraPath methodsFor: 'converting' stamp: 'bf 8/20/2010 17:26'!asFloatArray	^self floats! !!GeziraPath methodsFor: 'converting' stamp: 'bf 2/18/2010 21:30'!asGeziraPath	^self! !!GeziraPath methodsFor: 'converting' stamp: 'bf 8/20/2010 17:26'!size	^self floats size! !!GeziraPath methodsFor: 'converting' stamp: 'bf 5/24/2011 14:46'!transformedBy: aTransform 	^ self class new		points: (self points				collect: [:ps | ps asArray						collect: [:p | aTransform transformPointNoRound: p]])! !!GeziraPath methodsFor: 'converting' stamp: 'bf 10/28/2010 12:54'!withClosedContours	"Close each of the contours in this path with a line segment"	| thisA thisC prevC firstInContour contourStart newFloats |	thisC := nil.	newFloats := nil.	1 to: self floats size by: 6 do: [:i |		prevC := thisC.		thisA := (floats at: i)@(floats at: i+1).		thisC := (floats at: i+4)@(floats at: i+5).		i = 1 ifTrue: [			firstInContour := thisA.			contourStart := i].		(prevC notNil and: [prevC ~= thisA]) ifTrue: [			"contour ended"			firstInContour = prevC ifFalse: [				"not closed"				newFloats ifNil: [newFloats := floats copyFrom: 1 to: contourStart - 1].				newFloats := newFloats, (floats copyFrom: contourStart to: i - 1),					{prevC x. prevC y. prevC x. prevC y. firstInContour x. firstInContour y}.			].			firstInContour := thisA.			contourStart := i.		].	].	firstInContour = thisC ifFalse: [		"not closed"		newFloats ifNil: [newFloats := floats copyFrom: 1 to: contourStart - 1].		newFloats := newFloats, (floats copyFrom: contourStart to: floats size),		{thisC x. thisC y. thisC x. thisC y. firstInContour x. firstInContour y}].	^newFloats		ifNil: [self]		ifNotNil:[self clone floats: newFloats]! !!GeziraPath methodsFor: 'converting' stamp: 'tak 5/6/2011 13:48'!withFill: fillColor stroke: stroke strokeColor: strokeColor 	"Return a collection of GeziraFillPath or	GeziraStrokePath that have given color and border"	| paths |	paths := OrderedCollection new.	fillColor isTransparent		ifFalse: [paths				add: ((GeziraFilledPath path: self) withClosedContours fill: fillColor)].	stroke		ifNotNil: [(stroke width > 0					and: [strokeColor isTransparent not])				ifTrue: [paths add: ((GeziraStrokedPath path: self) fill: strokeColor;							 stroke: stroke)]].	^ paths! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 9/2/2010 14:57'!bounds	^self boundsWithTransform: MatrixTransform2x3 identity! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 10/11/2010 18:30'!boundsWithTransform: transform	^self boundsWithTransform: transform stroke: self stroke! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 6/11/2012 19:52'!boundsWithTransform: transform clip: aRectangle stroke: aStroke	"If no bound can be found within the clip rect, this answers a Rectangle with negative extent"	| bnds g |	bnds := FloatArray new: 4.	(g := GeziraBindings new)		kernels: (g pipeline:			{g funnel},			(aStroke ifNotNil: [				aStroke strokePipelineOn: g]			ifNil: [#()]),{			g transformBeziers: transform.			g clipBeziers: aRectangle.			g calculateBounds.			g capture: bnds});		pour: self floats from: 1 to: self floats size final: true;		sync.	^bnds first@bnds second corner: bnds third@bnds fourth! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 5/20/2011 18:14'!boundsWithTransform: transform stroke: aStroke	| bnds g |	bnds := FloatArray new: 4.	(g := GeziraBindings new)		kernels: (			g pipeline:				{g funnel},				(aStroke ifNil: [#()]					ifNotNil: [aStroke strokePipelineOn: g]				),				{				g transformBeziers: transform.				g calculateBounds.				g capture: bnds});		pour: self floats from: 1 to: self floats size final: true;		sync.	^bnds first@bnds second corner: bnds third@bnds fourth! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 9/2/2010 14:58'!containsPoint: aPoint	^self containsPoint: aPoint withTransform: MatrixTransform2x3 identity! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 10/11/2010 18:28'!containsPoint: aPoint withTransform: aTransform	^self containsPoint: aPoint withTransform: aTransform stroke: self stroke! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 10/28/2011 13:54'!containsPoint: aPoint withTransform: aTransform stroke: aStroke	| target g |	target := Form extent: 2@2 depth: 32.	"work around gezira out-of-bounds bug"	(g := GeziraBindings new)		kernels: (			g pipeline: (				{g funnel},				(aStroke ifNil: [#()]					ifNotNil: [aStroke strokePipelineOn: g]				),{				g transformBeziers: ((MatrixTransform2x3 withOffset: aPoint negated) composedWithLocal: aTransform).				g clipBeziers: (0@0 corner: 1@1). "target boundingBox -- work around gezira out-of-bounds bug"				g rasterize.				g compositeUniformColorCA: 1 cR: 1 cG: 1 cB: 1 overImageARGB32: target			}));		pour: self floats from: 1 to: self floats size final: true.	"GLOG ifNil: [GLOG := FileStream fileNamed: 'glog.txt'. GLOG setToEnd].	GLOG nextPutAll: g commandsStringC; flush."	g sync.	^target bits first > 0! !!GeziraPath methodsFor: 'accessing' stamp: 'tak 9/1/2011 16:15'!endTangentTransform	"Return a transform which rotates along the end tangent and move to the end."	| triplet direction |	triplet := self points first last: 3.	direction := (triplet third = triplet first		ifTrue: [1@0]		ifFalse: [triplet third - triplet first]) normalized.	^ MatrixTransform2x3 new		a11: direction x; a12: direction y negated; a13: triplet last x;		a21: direction y; a22: direction x;         a23: triplet last y.! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 10/4/2010 12:23'!fill	^nil! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 10/28/2010 12:25'!floats	^floats ifNil: [		floats := FloatArray streamContents: [:path |			points do: [:contour |				contour size \\ 3 = 0 ifFalse: [self error: 'invalid path'].				contour do: [:p |					path nextPut: p x; nextPut: p y]]]]! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 10/28/2010 13:46'!floats: anArray	floats := anArray asFloatArray.	floats size \\ 6 = 0 ifFalse: [self error: 'invalid path'].	points := nil.! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 10/15/2010 16:23'!minMax	| p min max |	min := max := nil.	self floats pairsDo: [:x :y |		p := x@y.		min := min ifNil: [p] ifNotNil: [min min: p].		max := max ifNil: [p] ifNotNil: [max max: p]].	^min corner: max! !!GeziraPath methodsFor: 'accessing' stamp: 'yo 8/29/2012 20:23'!minMaxWithTransform: aTransform	| p min max |	min := max := nil.	self floats pairsDo: [:x :y |		p := aTransform transformPoint: x@y.		min := min ifNil: [p] ifNotNil: [min min: p].		max := max ifNil: [p] ifNotNil: [max max: p]].	min ifNil: [min := 0.0@0.0].	max ifNil: [max := 0.0@0.0].	^min corner: max! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 2/18/2010 21:37'!points	^points ifNil: [		points := {floats pairsCollect: [:x :y | x@y]}]! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 8/28/2010 12:50'!points: anArrayOfContours	points := anArrayOfContours.	floats := nil.! !!GeziraPath methodsFor: 'accessing' stamp: 'tak 9/1/2011 16:14'!startTangentTransform	"Return a transform which rotates along the start tangent and move to the start."	| triplet direction p |	triplet := self points first first: 3.	p := triplet first = triplet second		ifTrue: [triplet third]		ifFalse: [triplet second].	direction := (triplet first = p		ifTrue: [1@0]		ifFalse: [triplet first - p]) normalized.	^ MatrixTransform2x3 new		a11: direction x; a12: direction y negated; a13: triplet first x;		a21: direction y; a22: direction x;         a23: triplet first y.! !!GeziraPath methodsFor: 'accessing' stamp: 'bf 10/4/2010 12:23'!stroke	^nil! !!GeziraPath methodsFor: 'drawing' stamp: 'bf 8/31/2010 16:51'!drawOn: aCanvas	aCanvas drawPath: self.! !!GeziraPath methodsFor: 'testing' stamp: 'bf 10/7/2010 11:37'!isClosed	| s first last |	s := self floats size.	first := (floats at: 1) @ (floats at: 2).	last := (floats at: s-1) @ (floats at: s).	^first = last! !!GeziraPath methodsFor: 'testing' stamp: 'yo 6/2/2011 15:15'!isRectangularSeriesFrom: index equalsTo: v	floats size = 24 ifFalse: [^ false].	0 to: 10 do: [:i |		(floats atWrap: (index + i)) = v ifFalse: [^ false]].	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GeziraPath class	instanceVariableNames: ''!!GeziraPath class methodsFor: 'instance creation' stamp: 'yo 9/1/2010 01:02'!arc: x	^ self arc: 0 to: x.! !!GeziraPath class methodsFor: 'instance creation' stamp: 'yo 9/1/2010 00:48'!arc: x to: y	^ self new points: {(self arcPoints: x to: y)}.! !!GeziraPath class methodsFor: 'instance creation' stamp: 'yo 9/7/2010 13:59'!arc: x to: y center: c radius: r	| a |	a := self arcPoints: x to: y center: c radius: r.	^ self new points: {(Array with: c with: c with: a first), a, (Array with: a last with: a last with: c)}.! !!GeziraPath class methodsFor: 'instance creation' stamp: 'tak 5/10/2011 15:06'!arcPoints: from to: to center: centerPoint radius: radius	| x y p0 p2 p1 points more last step |	step := Float pi/4.	points := WriteStream on: (Array new: ((to - from)/step) asInteger * 3).	x := from.	y := x + step.	p0 := ((x cos@x sin) * radius) + centerPoint.	"points nextPut: centerPoint; nextPut: centerPoint; nextPut: p0."	more := true.	last := false.	[more] whileTrue: [		p2 := ((y cos@y sin) * radius) + centerPoint.		p1 := (((-0.5 * (x cos + y cos) + (2 * (0.5*(x+y)) cos))@(-0.5 * (x sin + y sin) + (2 * (0.5 * (x + y)) sin))) * radius) + centerPoint.		points nextPut: p0; nextPut: p1; nextPut: p2.		x := y.		last ifTrue: [more := false].		y := (x + step >= to) ifTrue: [last := true. to] ifFalse: [x + step].		p0 := p2.	].	"points nextPut: p0; nextPut: p0; nextPut: centerPoint."	^ points contents.	! !!GeziraPath class methodsFor: 'instance creation' stamp: 'bf 10/7/2010 16:53'!build: aBlock	| builder |	builder := GeziraPathBuilder new.	aBlock value: builder.	^self new floats: builder floats! !!GeziraPath class methodsFor: 'instance creation' stamp: 'bf 8/30/2010 22:15'!line: fromPoint to: toPoint	^self new points: {{fromPoint. fromPoint. toPoint}}! !!GeziraPath class methodsFor: 'instance creation' stamp: 'bf 10/28/2010 23:58'!oval: aRectangle	| a b c d e |	a := 0.1464466094067263. "(1 - sin(pi/4)) / 2"	b := 0.308658283817455.  "(1 - sin(pi/8)) / 2"	c := 0.5.	d := 1-b.	e := 1-a.	^self new points: {		{			0@c. 0@b. a@a. a@a. b@0. c@0.			c@0. d@0. e@a. e@a. 1@b. 1@c.			1@c. 1@d. e@e. e@e. d@1. c@1.			c@1. b@1. a@e. a@e. 0@d. 0@c		} collect: [:p | p * aRectangle extent + aRectangle origin]}! !!GeziraPath class methodsFor: 'instance creation' stamp: 'bf 9/1/2010 16:50'!path: aPath	self class == aPath class		ifTrue: [^aPath].	^self new, aPath asGeziraPath! !!GeziraPath class methodsFor: 'instance creation' stamp: 'bf 8/26/2010 23:09'!polygon: aPointArray	^self new points: {		Array streamContents: [:stream |			aPointArray withIndexDo: [:p1 :i | | p2 |				p2 := aPointArray atWrap: i + 1.				stream nextPut: p1; nextPut: p2; nextPut: p2]]}! !!GeziraPath class methodsFor: 'instance creation' stamp: 'bf 9/3/2010 16:50'!polyline: aPointArray	^self new points: {		Array streamContents: [:stream |			1 to: aPointArray size - 1 do: [:i | | p1 p2 |				p1 := aPointArray at: i.				p2 := aPointArray at: i + 1.				stream nextPut: p1; nextPut: p2; nextPut: p2]]}! !!GeziraPath class methodsFor: 'instance creation' stamp: 'bf 10/18/2010 14:08'!rect: rect radii: anArray 	|rs tl bl br tr |	(anArray allSatisfy: [:r | r <= 0])		ifTrue: [^self path: rect asGeziraPath].	rs := anArray collect: [:r |((r max: 0.0) min: rect width * 0.5) min: rect height * 0.5].	tl := rs first.	bl := rs second.	br := rs third.	tr := rs fourth.	^self build: [:builder | builder		pos: rect topLeft + (0.0@tl) dir: 0.0 @ -1.0;		right: tl; line: rect width - tl - tr;		right: tr; line: rect height - tr - br;		right: br; line: rect width - br - bl;		right: bl; close	]! !!GeziraPath class methodsFor: 'instance creation' stamp: 'bf 6/12/2012 17:30'!rect: rect radii: anArray edges: bs	|rs tl bl br tr size open segments b blocks last ret |	open := (bs occurrencesOf: false) > 0.	open ifFalse: [^ {self rect: rect radii: anArray}].	"When it is either #(top bottom) or #(left right), the result needs to be an array of two elements."	size := (bs = #(true false true false) or: [bs = #(false true false true)]) ifTrue: [2] ifFalse: [1].	rs := anArray collect: [:r |((r max: 0.0) min: rect width * 0.5) min: rect height * 0.5].	tl := rs first.	bl := rs second.	br := rs third.	tr := rs fourth.	"Construct the potential 8 (4 edges and 4 corners) segments.  When the radius is 0 for a corner, it does not contain any points; so the number of points from this method is not a constant (24).  So, we collect each of these 8 things separately first."	segments := Array new: 8.	b := GeziraPathBuilder new.	b pos: rect topLeft + (tl@0) dir: 1@0.	blocks := {[b line: rect width - tl - tr]. [b right: tr]. [b line: rect height - tr - br]. [b right: br].				[b line: rect width - br - bl]. [b right: bl]. [b line: rect height - bl - tl]. [b right: tl]}.	last := b count + 1.	1 to: 8 do: [:i |		(blocks at: i) value.		segments at: i put: (b floats copyFrom: last to: b count).		last := b count + 1].	"When the result is one path, start from the empty edge and go around the segments."	size = 1 ifTrue: [		ret := Array new writeStream.		0 to: 3 do: [:i |			(bs atWrap: i + 1) ifTrue: [				ret nextPutAll: (segments atWrap: (i * 2) + 1)].			ret nextPutAll: (segments atWrap: (i * 2) + 2)].		^ {self new floats: ret contents}].	"When the result is two paths."	^ #(0 2) collect: [:i |			ret := Array new writeStream.			ret nextPutAll: (segments atWrap: (i * 2)).			ret nextPutAll: (segments atWrap: (i * 2) + 1).			ret nextPutAll: (segments atWrap: (i * 2) + 2).			self new floats: ret contents]! !!GeziraPath class methodsFor: 'instance creation' stamp: 'bf 10/18/2010 13:04'!rect: rect radius: radius	| r |	radius <= 0		ifTrue: [^self path: rect asGeziraPath].	r := (radius min: rect width * 0.5) min: rect height * 0.5.	^ self build: [:builder | builder		pos: rect topLeft + (0.0 @ r) dir: (0.0 @ -1.0);		right: r; line: rect width - (2.0 * r);		right: r; line: rect height - (2.0 * r);		right: r; line: rect width - (2.0 * r);		right: r; close	]! !!GeziraPath class methodsFor: 'instance creation' stamp: 'bf 10/18/2010 14:18'!rect: rect radius: radius at: whichCorners	"whichCorners is an array of symbols specifying which corners to round (that is, any combination of #all, #bottom, #bottomLeft, #bottomRight, #left, #right, #top, #topLeft, #topRight)"	^self rect: rect radii: (#(		(left top topLeft all)		(left bottom bottomLeft all)		(right bottom bottomRight all)		(right top topRight all)) collect: [:corners |			((corners includes: whichCorners) or: [corners includesAnyOf: whichCorners])				ifTrue: [radius]				ifFalse: [0]])! !!GeziraPath class methodsFor: 'instance creation' stamp: 'yo 10/27/2010 00:53'!rect: rect radius: radius at: whichCorners edges: whichEdges	"whichCorners is an array of symbols specifying which corners to round (that is, any combination of #all, #bottom, #bottomLeft, #bottomRight, #left, #right, #top, #topLeft, #topRight)"	"whichEdges is an array of symbols specifying which edges to have (that is, any combination of #all, #bottom, #left, #right, #top)."	^self rect: rect radii: (#(		(left top topLeft all)		(left bottom bottomLeft all)		(right bottom bottomRight all)		(right top topRight all)) collect: [:corners |			((corners includes: whichCorners) or: [corners includesAnyOf: whichCorners])				ifTrue: [radius]				ifFalse: [0]])		edges: (#((top all) (right all) (bottom all) (left all)) collect: [:edges |			((edges includes: whichEdges) or: [edges includesAnyOf: whichEdges])])! !!GeziraPath class methodsFor: 'instance creation' stamp: 'yo 9/21/2012 15:11'!sketchyLineFrom: from to: to p: p	^ self new points: {self sketchyPointsFrom: from to: to p: p}.! !!GeziraPath class methodsFor: 'instance creation' stamp: 'yo 9/21/2012 15:26'!sketchyRect: aRectangle	| ps origin corner p |	origin := aRectangle origin.	corner := aRectangle corner.	p := 0.05.	ps := Array streamContents: [:strm |		strm nextPutAll: (self sketchyPointsFrom: origin to: (corner x@origin y) p: p).		strm nextPutAll: (self sketchyPointsFrom: (corner x@origin y) to: corner p: p).		strm nextPutAll: (self sketchyPointsFrom: corner to: (origin x@corner y) p: p).		strm nextPutAll: (self sketchyPointsFrom: (origin x@corner y) to: origin p: p)].	^ self new points: {ps}.! !!GeziraPath class methodsFor: 'private' stamp: 'yo 9/21/2012 15:47'!noiseSamplesFrom: from to: to p: p	| rand unit unitP unitMag |	rand := Random new.	unit := to - from.	unitMag := unit r.	unitMag <= 1.0 ifTrue: [^ #()].	unitP := (unit y@unit x negated) * p / (unitMag log: 8).	^ (0.0 to: 1.0 by: 0.125) collect: [:f |		from + (unit * f) + (((f = 0.0 or: [f = 1.0]) ifTrue: [0.0] ifFalse: [rand next - 0.5]) * unitP)].! !!GeziraPath class methodsFor: 'private' stamp: 'yo 9/21/2012 15:47'!sketchyPointsFrom: from to: to p: p	| sequence midPoints points |	sequence := self noiseSamplesFrom: from to: to p: p.	sequence size = 0 ifTrue: [^ #()].	midPoints := (1 to: sequence size - 1) collect: [:i |		((sequence at: i) + (sequence at: i+1)) / 2.0].	points := Array streamContents: [:strm |		strm nextPut: (sequence at: 1);				nextPut: (sequence at: 1);				nextPut: (midPoints at: 1).		2 to: sequence size - 1 do: [:i |			strm				nextPut: (midPoints at: i-1);				nextPut: (sequence at: i);				nextPut: (midPoints at: i)].		strm			nextPut: (midPoints last);			nextPut: (midPoints last);			nextPut: (sequence last)].	^ points.			! !GeziraPath subclass: #GeziraFilledPath	instanceVariableNames: 'fill'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraFilledPath methodsFor: 'drawing' stamp: 'bf 9/30/2010 17:48'!drawOn: aCanvas	fill ifNotNil: [aCanvas fill: fill].	super	drawOn: aCanvas.! !!GeziraFilledPath methodsFor: 'accessing' stamp: 'bf 8/31/2010 16:24'!fill	^fill! !!GeziraFilledPath methodsFor: 'accessing' stamp: 'bf 10/5/2010 19:12'!fill: aFill	fill := aFill ifNotNil: [aFill asGeziraFill]! !!GeziraFilledPath methodsFor: 'converting' stamp: 'tak 9/2/2011 14:27'!transformedBy: aTransform 	| path |	path := super transformedBy: aTransform.	path fill: fill.	^ path.! !Object subclass: #GeziraPathBuilder	instanceVariableNames: 'floats stream pos dir'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraPathBuilder methodsFor: 'building' stamp: 'bf 10/18/2010 12:53'!close	"Add a line from current position to first point"	pos = (floats first @ floats second) ifFalse: [		self vertex: 0; vertex: 0.		stream nextPut: floats first; nextPut: floats second].! !!GeziraPathBuilder methodsFor: 'building' stamp: 'bf 10/7/2010 16:51'!floats	^stream contents! !!GeziraPathBuilder methodsFor: 'building' stamp: 'bf 10/7/2010 16:28'!left: radius	"Turn left with given radius, sharp turn if 0"	radius > 0 ifTrue: [		self vertex: 0; vertex: radius.		dir := dir y @ dir x negated.		self vertex: radius.	] ifFalse: [		dir := dir y @ dir x negated.	]! !!GeziraPathBuilder methodsFor: 'building' stamp: 'bf 10/18/2010 12:39'!line: length	"append straight line segment of given length"	length > 0 ifTrue: [self vertex: 0; vertex: 0; vertex: length].! !!GeziraPathBuilder methodsFor: 'building' stamp: 'bf 10/7/2010 16:28'!right: radius	"Turn right with given radius, sharp turn if 0"	radius > 0 ifTrue: [		self vertex: 0; vertex: radius.		dir := dir y negated @ dir x.		self vertex: radius.	] ifFalse: [		dir := dir y negated @ dir x	]! !!GeziraPathBuilder methodsFor: 'building' stamp: 'yo 6/6/2012 09:36'!turn: radian	dir := dir rotateBy: radian about: 0@0! !!GeziraPathBuilder methodsFor: 'private' stamp: 'yo 10/26/2010 23:19'!count	^ stream contents size.! !!GeziraPathBuilder methodsFor: 'private' stamp: 'bf 10/7/2010 16:44'!vertex: distance	pos := pos + (dir * distance).	stream nextPut: pos x; nextPut: pos y.! !!GeziraPathBuilder methodsFor: 'initialization' stamp: 'bf 10/7/2010 16:47'!pos: position dir: direction	pos := position.	dir := direction.	floats := FloatArray new: 96.	stream := floats writeStream.! !GeziraCanvas subclass: #GeziraShadowCanvas	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraShadowCanvas commentStamp: 'bf 9/23/2010 14:14' prior: 0!I ignore regular fill: messages. To change my fill use #shadowFill:!!GeziraShadowCanvas methodsFor: 'accessing' stamp: 'bf 9/23/2010 15:19'!fill: aGeziraFill	"ignore"! !!GeziraShadowCanvas methodsFor: 'accessing' stamp: 'bf 10/8/2010 15:08'!shadowFill: aGeziraFill	fill := aGeziraFill asGeziraFill.! !!GeziraShadowCanvas methodsFor: 'testing' stamp: 'bf 9/23/2010 14:15'!isShadowCanvas	^true! !Object subclass: #GeziraStroke	instanceVariableNames: 'width joints caps'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraStroke methodsFor: 'accessing' stamp: 'bf 8/20/2010 15:14'!caps	^ caps! !!GeziraStroke methodsFor: 'accessing' stamp: 'bf 8/20/2010 15:14'!caps: miterOrRound	caps := miterOrRound! !!GeziraStroke methodsFor: 'accessing' stamp: 'bf 8/20/2010 15:15'!joints	^ joints! !!GeziraStroke methodsFor: 'accessing' stamp: 'bf 8/20/2010 15:14'!joints: miterOrRound	joints := miterOrRound! !!GeziraStroke methodsFor: 'accessing' stamp: 'bf 8/20/2010 15:14'!width	^ width! !!GeziraStroke methodsFor: 'accessing' stamp: 'bf 8/20/2010 15:14'!width: aNumber	width := aNumber! !!GeziraStroke methodsFor: 'rendering' stamp: 'bf 10/17/2011 19:12'!strokePipelineOn: g	^{g strokeBezierPathW: width l: joints limit c: caps limit}! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GeziraStroke class	instanceVariableNames: ''!!GeziraStroke class methodsFor: 'joints and caps' stamp: 'bf 5/31/2011 19:35'!miter	"default miter style"	^ self miter: 4! !!GeziraStroke class methodsFor: 'joints and caps' stamp: 'bf 5/31/2011 21:33'!miter: lNumber	^ GeziraStrokeMiter new		limit: lNumber! !!GeziraStroke class methodsFor: 'joints and caps' stamp: 'bf 8/20/2010 15:16'!round	^ GeziraStrokeRound new! !!GeziraStroke class methodsFor: 'old bindings' stamp: 'tk 11/15/2011 10:48'!miterLimit: limit distance: distTranscript show: 'Need to remove ', thisContext selector, ' send in ', thisContext sender method asString; cr.	^self miter: limit! !!GeziraStroke class methodsFor: 'instance creation' stamp: 'bf 8/31/2010 16:55'!round: aNumber 	^ self width: aNumber joints: self round caps: self round! !!GeziraStroke class methodsFor: 'instance creation' stamp: 'bf 11/28/2011 20:30'!width: aNumber 	"default stroke uses miter joints and butted caps"	^ self width: aNumber joints: self miter caps: (self miter: 0.0)! !!GeziraStroke class methodsFor: 'instance creation' stamp: 'bf 8/20/2010 15:28'!width: aNumber joints: jMiterOrRound caps: cMiterOrRound	^ self new		width: aNumber;		joints: jMiterOrRound;		caps: cMiterOrRound! !Object subclass: #GeziraStrokeMiter	instanceVariableNames: 'limit distance'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraStrokeMiter methodsFor: 'accessing' stamp: 'bf 8/20/2010 15:06'!limit	^limit! !!GeziraStrokeMiter methodsFor: 'accessing' stamp: 'bf 8/20/2010 15:06'!limit: aNumber	limit := aNumber! !Object subclass: #GeziraStrokeRound	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraStrokeRound methodsFor: 'accessing' stamp: 'bf 5/31/2011 19:39'!limit	^-1.0! !GeziraFilledPath subclass: #GeziraStrokedPath	instanceVariableNames: 'stroke'	classVariableNames: ''	poolDictionaries: ''	category: 'GeziraBindings-Base'!!GeziraStrokedPath methodsFor: 'accessing' stamp: 'bf 10/11/2010 18:30'!boundsWithTransform: transform stroke: aStroke	^super boundsWithTransform: transform		stroke: (stroke ifNotNil: [stroke] ifNil: [aStroke])! !!GeziraStrokedPath methodsFor: 'accessing' stamp: 'bf 10/11/2010 18:29'!containsPoint: aPoint withTransform: aTransform stroke: aStroke	^super containsPoint: aPoint		withTransform: aTransform		stroke: (stroke ifNotNil: [stroke] ifNil: [aStroke])! !!GeziraStrokedPath methodsFor: 'accessing' stamp: 'bf 8/31/2010 21:34'!stroke	^stroke! !!GeziraStrokedPath methodsFor: 'accessing' stamp: 'bf 8/31/2010 21:34'!stroke: aStroke	stroke := aStroke! !!GeziraStrokedPath methodsFor: 'drawing' stamp: 'bf 9/30/2010 17:48'!drawOn: aCanvas	stroke ifNotNil: [aCanvas stroke: stroke]. 	super drawOn: aCanvas! !!GeziraStrokedPath methodsFor: 'converting' stamp: 'tak 9/2/2011 14:28'!transformedBy: aTransform 	| path |	path := super transformedBy: aTransform.	path stroke: stroke.	^ path.! !GeziraBindings initialize!!MatrixTransform2x3 methodsFor: '*gezirabindings-base' stamp: 'bf 12/13/2011 13:28'!isAxisAligning	"Return true if a transformed rectangle will still be axis-aligned, i.e. translated, scaled, and/or rotated by multiples of 90 degrees"	^(self a12 = 0.0 and: [self a21 = 0.0])		or: [self a11 = 0.0 and: [self a22 = 0.0]]! !!MatrixTransform2x3 methodsFor: '*gezirabindings-base' stamp: 'bf 11/22/2011 18:41'!localBounds: srcRect toGlobalNoRound: dstRect	"Transform aRectangle from local coordinates into the coordinates of its container.  Answer is NOT in truly global coordinates. "	<primitive: 'primitiveTransformRectInto' module: 'GeziraBindingsMT'>	^super localBoundsToGlobal: srcRect! !!MatrixTransform2x3 methodsFor: '*gezirabindings-base' stamp: 'tk 2/4/2011 11:21'!localBoundsToGlobalNoRound: aRectangle		"Transform aRectangle from local coordinates into the coordinates of its container.  Answer is NOT in truly global coordinates. "	^self localBounds: aRectangle toGlobalNoRound: Rectangle new! !!MatrixTransform2x3 methodsFor: '*gezirabindings-base' stamp: 'bf 11/22/2011 18:41'!transformPointNoRound: aPoint	"Transform aPoint from local coordinates into global coordinates"	<primitive: 'primitiveTransformPoint' module: 'GeziraBindingsMT'>	| x y |	x := (aPoint x * self a11) + (aPoint y * self a12) + self a13.	y := (aPoint x * self a21) + (aPoint y * self a22) + self a23.	^x @ y! !!Collection methodsFor: '*gezirabindings-base' stamp: 'bf 8/28/2010 12:53'!asGeziraPath	^self anyOne isNumber		ifTrue: [GeziraPath new floats: self]		ifFalse: [GeziraPath new points: self]! !!Form methodsFor: '*gezirabindings-base' stamp: 'bf 9/19/2011 12:15'!asGeziraFill	^GeziraFill image: self! !!TTGlyph methodsFor: '*gezirabindings-base' stamp: 'tak 5/9/2011 14:58'!asGeziraPath	self buildAllContours.	^GeziraPath new points: self contours! !!Rectangle methodsFor: '*gezirabindings-base' stamp: 'bf 9/14/2011 15:07'!clippedBy: aRectangle 	"Like intersect: but ensures non-negative extent"	| aPoint left right top bottom |	aPoint := aRectangle origin.	aPoint x > origin x ifTrue:[left := aPoint x] ifFalse:[left := origin x].	aPoint y > origin y ifTrue:[top := aPoint y] ifFalse:[top := origin y].	aPoint := aRectangle corner.	aPoint x < corner x ifTrue:[right := aPoint x] ifFalse:[right := corner x].	aPoint y < corner y ifTrue:[bottom := aPoint y] ifFalse:[bottom := corner y].	right < left ifTrue: [right := left].	bottom < top ifTrue: [bottom := top].	^Rectangle		origin: (left@top)		corner: (right max: left)@(bottom max: top)! !!Rectangle methodsFor: '*gezirabindings-base' stamp: 'bf 8/27/2010 00:42'!asGeziraPath	^GeziraPath new floats: {		origin x. origin y.  origin x. origin y.  corner x. origin y.		corner x. origin y.  corner x. origin y.  corner x. corner y.		corner x. corner y.  corner x. corner y.  origin x. corner y.		origin x. corner y.  origin x. corner y.  origin x. origin y}! !		!Point methodsFor: 'truncation and rounding' stamp: '??? 8/27/2010 00:42'!roundTo: n	^(x roundTo: n x) @ (y roundTo: n y)! !