SmartSyntaxInterpreterPlugin subclass: #GeziraBindingsMTPlugin	instanceVariableNames: 'threads init mem memSize stack stackP images wasSync errorMsg errorItem errorCode m23ArgX m23ArgY m23ResultX m23ResultY'	classVariableNames: 'NileBufferSize'	poolDictionaries: ''	category: 'GeziraBindingsMT-Plugin'!!GeziraBindingsMTPlugin commentStamp: 'bf 8/2/2010 16:55' prior: 0!This plugin interfaces to Gezira. It uses a stack-based approach to assemble kernels.Variables:	mem    -- a chunk of memory	nile   -- the nile instance, using the memory mem	stack  -- an array of nile kernels	stackP -- number of kernels on the stackEach primitive corresponds to a particular Gezira kernel. It creates the kernel and pushes it onto the stack. Kernel arguments are passed as primitive parameters or on the stack depending on their type (kernels on the kernel stack, reals as primitive arguments). The left-most kernel argument needs to be pushed first.The kernel primitives are generated, see GeziraBindings class>>generatePrimitives.Example	| target vertices |	"Smalltalk unloadModule: 'GeziraBindings'"	target := (Display copy: (0@0 extent: 400@300)) asFormOfDepth: 32.	vertices := GeziraCanvas star.	GeziraBindings new			primTransformBeziersMA: 1.0 mB: 0.0 mC: 0.0 mD: 1.0 mE: 150.0 mF: 150.0;			primClipBeziersMinX: 0.0 minY: 0.0 maxX: target width asFloat maxY: target height asFloat;					primUniformColorCA: 0.5 cR: 1.0 cG: 0.0 cB: 0.0;					primReadImageARGB32: target;					primCompositeOver;				primCompositeSamplers;				primWriteImageARGB32: target;			primRender;		primPipeline: 3;		primFeed: vertices asFloatArray from: 1 to: vertices size by: 6;		primSync.	target display!!GeziraBindingsMTPlugin methodsFor: 'misc' stamp: 'bf 7/20/2012 14:57'!checkNileError	errorCode := self cCode: 'nile_status(init)'.	errorCode ~= (self cCode: 'NILE_STATUS_OK') ifTrue: [		self fail: 'nile error'].! !!GeziraBindingsMTPlugin methodsFor: 'misc' stamp: 'bf 3/14/2011 20:27'!fail: aString	self var: #aString type: 'char*'.	self msg: aString.		errorMsg := aString.	interpreterProxy success: false.	^nil! !!GeziraBindingsMTPlugin methodsFor: 'misc' stamp: 'bf 11/18/2011 18:24'!imageFromForm: formOop	| i pixels depth height width |	self returnTypeC: 'gezira_Image_t*'.	self var: #pixels type: 'usqInt*'.	(interpreterProxy slotSizeOf: formOop) < 4 ifTrue: [self fail: 'invalid form'. ^nil].	pixels := interpreterProxy fetchArray: 0 ofObject: formOop.	i := 0.	[i < (images sizeof / (images at: 0) sizeof)		and: [self cCode: 'images[i].pixels !!= NULL']	] whileTrue: [		pixels = (self cCode: 'images[i].pixels')			ifTrue: [^self cCode: '&images[i]'].		i:= i + 1].	i < (images sizeof / (images at: 0) sizeof)		ifFalse: [self fail: 'too many images'. ^nil].	width := interpreterProxy fetchInteger: 1 ofObject: formOop.	height := interpreterProxy fetchInteger: 2 ofObject: formOop.	depth := interpreterProxy fetchInteger: 3 ofObject: formOop.	interpreterProxy failed ifTrue: [self fail: 'invalid form'. ^nil].	(depth ~= 32) ifTrue: [self fail: 'form must have depth 32'. ^nil].	self cCode: 'gezira_Image_init (&images[i], pixels, width, height, width)' inSmalltalk: [width. height].	^self cCode: '&images[i]'! !!GeziraBindingsMTPlugin methodsFor: 'misc' stamp: 'bf 3/8/2011 15:49'!popKernel	self returnTypeC: #'nile_Process_t*'.	stackP > 0		ifFalse: [self fail: 'kernel stack underflow'. ^nil].	stackP := stackP - 1.	^stack at: stackP! !!GeziraBindingsMTPlugin methodsFor: 'misc' stamp: 'bf 3/8/2011 15:49'!popKernels: n	self returnTypeC: #'nile_Process_t**'.	stackP >= n		ifFalse: [self fail: 'kernel stack underflow'. ^nil].	stackP := stackP - n.	^stack + stackP! !!GeziraBindingsMTPlugin methodsFor: 'misc' stamp: 'bf 3/14/2011 13:15'!pushKernel: aKernel	self inline: true.	self returnTypeC: 'void'.	self var: #aKernel type: #'nile_Process_t*'.	stackP < (stack sizeof / (stack at: 0) sizeof)		ifFalse: [self fail: 'kernel stack overflow'. ^nil].	stack at: stackP put: aKernel.	stackP := stackP + 1.! !!GeziraBindingsMTPlugin methodsFor: 'misc' stamp: 'bf 8/10/2010 17:07'!string: zeroTerminated equals: notTerminated len: length	self var: #zeroTerminated type: 'char*'.	self var: #notTerminated type: 'char*'.	self inline: true.	^0 = (self str: zeroTerminated n: notTerminated cmp: length)		and: [0 = (zeroTerminated at: length)]! !!GeziraBindingsMTPlugin methodsFor: 'misc' stamp: 'bf 3/8/2011 15:49'!topKernel	self returnTypeC: #'nile_Process_t*'.	stackP < 1		ifTrue: [self fail: 'empty stack'. ^nil].	^stack at: stackP - 1! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 11/11/2011 20:44'!dispatchKernel: kernelName size: kernelNameSize arguments: argOops size: argCount	"Automatically generated (see generatePluginDispatch)"	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #kernelName type: 'char*'.	(self string: 'Funnel' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelFunnel: argOops size: argCount].	(self string: 'Pipeline' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelPipeline: argOops size: argCount].	(self string: 'Capture' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCapture: argOops size: argCount].	(self string: 'ReadFromImageARGB32' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelReadFromImageARGB32: argOops size: argCount].	(self string: 'WriteToImageARGB32' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelWriteToImageARGB32: argOops size: argCount].	(self string: 'CompositeUniformColorOverImageARGB32' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeUniformColorOverImageARGB32: argOops size: argCount].	(self string: 'ApplyColorSpans' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelApplyColorSpans: argOops size: argCount].	(self string: 'ApplyTexture' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelApplyTexture: argOops size: argCount].	(self string: 'BicubicFilter' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelBicubicFilter: argOops size: argCount].	(self string: 'BilinearFilter' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelBilinearFilter: argOops size: argCount].	(self string: 'CalculateBounds' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCalculateBounds: argOops size: argCount].	(self string: 'ClipBeziers' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelClipBeziers: argOops size: argCount].	(self string: 'ColorSpan' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelColorSpan: argOops size: argCount].	(self string: 'CompositeClear' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeClear: argOops size: argCount].	(self string: 'CompositeColorBurn' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeColorBurn: argOops size: argCount].	(self string: 'CompositeColorDodge' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeColorDodge: argOops size: argCount].	(self string: 'CompositeDarken' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeDarken: argOops size: argCount].	(self string: 'CompositeDifference' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeDifference: argOops size: argCount].	(self string: 'CompositeDst' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeDst: argOops size: argCount].	(self string: 'CompositeDstAtop' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeDstAtop: argOops size: argCount].	(self string: 'CompositeDstIn' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeDstIn: argOops size: argCount].	(self string: 'CompositeDstOut' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeDstOut: argOops size: argCount].	(self string: 'CompositeDstOver' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeDstOver: argOops size: argCount].	(self string: 'CompositeExclusion' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeExclusion: argOops size: argCount].	(self string: 'CompositeHardLight' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeHardLight: argOops size: argCount].	(self string: 'CompositeInvert' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeInvert: argOops size: argCount].	(self string: 'CompositeLighten' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeLighten: argOops size: argCount].	(self string: 'CompositeMultiply' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeMultiply: argOops size: argCount].	(self string: 'CompositeOver' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeOver: argOops size: argCount].	(self string: 'CompositeOverlay' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeOverlay: argOops size: argCount].	(self string: 'CompositePlus' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositePlus: argOops size: argCount].	(self string: 'CompositeScreen' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeScreen: argOops size: argCount].	(self string: 'CompositeSoftLight' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeSoftLight: argOops size: argCount].	(self string: 'CompositeSrc' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeSrc: argOops size: argCount].	(self string: 'CompositeSrcAtop' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeSrcAtop: argOops size: argCount].	(self string: 'CompositeSrcIn' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeSrcIn: argOops size: argCount].	(self string: 'CompositeSrcOut' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeSrcOut: argOops size: argCount].	(self string: 'CompositeSubtract' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeSubtract: argOops size: argCount].	(self string: 'CompositeTextures' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeTextures: argOops size: argCount].	(self string: 'CompositeXor' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelCompositeXor: argOops size: argCount].	(self string: 'ContrastiveOver' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelContrastiveOver: argOops size: argCount].	(self string: 'GaussianBlur11x1' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelGaussianBlur11x1: argOops size: argCount].	(self string: 'GaussianBlur1x11' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelGaussianBlur1x11: argOops size: argCount].	(self string: 'GaussianBlur1x21' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelGaussianBlur1x21: argOops size: argCount].	(self string: 'GaussianBlur1x5' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelGaussianBlur1x5: argOops size: argCount].	(self string: 'GaussianBlur21x1' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelGaussianBlur21x1: argOops size: argCount].	(self string: 'GaussianBlur5x1' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelGaussianBlur5x1: argOops size: argCount].	(self string: 'InverseOver' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelInverseOver: argOops size: argCount].	(self string: 'LinearGradient' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelLinearGradient: argOops size: argCount].	(self string: 'PadGradient' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelPadGradient: argOops size: argCount].	(self string: 'PadTexture' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelPadTexture: argOops size: argCount].	(self string: 'RadialGradient' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelRadialGradient: argOops size: argCount].	(self string: 'Rasterize' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelRasterize: argOops size: argCount].	(self string: 'RectangleSpans' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelRectangleSpans: argOops size: argCount].	(self string: 'ReflectGradient' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelReflectGradient: argOops size: argCount].	(self string: 'ReflectTexture' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelReflectTexture: argOops size: argCount].	(self string: 'RepeatGradient' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelRepeatGradient: argOops size: argCount].	(self string: 'RepeatTexture' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelRepeatTexture: argOops size: argCount].	(self string: 'StrokeBezierPath' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelStrokeBezierPath: argOops size: argCount].	(self string: 'TransformBeziers' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelTransformBeziers: argOops size: argCount].	(self string: 'TransformPoints' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelTransformPoints: argOops size: argCount].	(self string: 'UniformColor' equals: kernelName len: kernelNameSize)		ifTrue: [^self kernelUniformColor: argOops size: argCount].	self fail: 'Unknown kernel'! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 11/11/2011 20:44'!kernelApplyColorSpans: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result spans |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #spans type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in ApplyColorSpans'].	spans := self popKernel.	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to ApplyColorSpans'].	result := self cCode: 'gezira_ApplyColorSpans(init, spans)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelApplyTexture: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result t |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #t type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in ApplyTexture'].	t := self popKernel.	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to ApplyTexture'].	result := self cCode: 'gezira_ApplyTexture(init, t)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelBicubicFilter: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result t |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #t type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in BicubicFilter'].	t := self popKernel.	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to BicubicFilter'].	result := self cCode: 'gezira_BicubicFilter(init, t)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelBilinearFilter: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result t |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #t type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in BilinearFilter'].	t := self popKernel.	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to BilinearFilter'].	result := self cCode: 'gezira_BilinearFilter(init, t)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCalculateBounds: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CalculateBounds'].	result := self cCode: 'gezira_CalculateBounds(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelClipBeziers: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result minX minY maxX maxY |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #minX type: 'float'.	self var: #minY type: 'float'.	self var: #maxX type: 'float'.	self var: #maxY type: 'float'.	argCount ~= 4		ifTrue: [^self fail: 'wrong argument count in ClipBeziers'].	minX := interpreterProxy floatValueOf: (argOops at: 0).	minY := interpreterProxy floatValueOf: (argOops at: 1).	maxX := interpreterProxy floatValueOf: (argOops at: 2).	maxY := interpreterProxy floatValueOf: (argOops at: 3).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to ClipBeziers'].	result := self cCode: 'gezira_ClipBeziers(init, minX, minY, maxX, maxY)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 9/22/2011 14:51'!kernelColorSpan: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result s1A s1R s1G s1B s2A s2R s2G s2B l |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #s1A type: 'float'.	self var: #s1R type: 'float'.	self var: #s1G type: 'float'.	self var: #s1B type: 'float'.	self var: #s2A type: 'float'.	self var: #s2R type: 'float'.	self var: #s2G type: 'float'.	self var: #s2B type: 'float'.	self var: #l type: 'float'.	argCount ~= 9		ifTrue: [^self fail: 'wrong argument count in ColorSpan'].	s1A := interpreterProxy floatValueOf: (argOops at: 0).	s1R := interpreterProxy floatValueOf: (argOops at: 1).	s1G := interpreterProxy floatValueOf: (argOops at: 2).	s1B := interpreterProxy floatValueOf: (argOops at: 3).	s2A := interpreterProxy floatValueOf: (argOops at: 4).	s2R := interpreterProxy floatValueOf: (argOops at: 5).	s2G := interpreterProxy floatValueOf: (argOops at: 6).	s2B := interpreterProxy floatValueOf: (argOops at: 7).	l := interpreterProxy floatValueOf: (argOops at: 8).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to ColorSpan'].	result := self cCode: 'gezira_ColorSpan(init, s1A, s1R, s1G, s1B, s2A, s2R, s2G, s2B, l)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeClear: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeClear'].	result := self cCode: 'gezira_CompositeClear(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeColorBurn: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeColorBurn'].	result := self cCode: 'gezira_CompositeColorBurn(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeColorDodge: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeColorDodge'].	result := self cCode: 'gezira_CompositeColorDodge(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeDarken: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeDarken'].	result := self cCode: 'gezira_CompositeDarken(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeDifference: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeDifference'].	result := self cCode: 'gezira_CompositeDifference(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeDst: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeDst'].	result := self cCode: 'gezira_CompositeDst(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeDstAtop: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeDstAtop'].	result := self cCode: 'gezira_CompositeDstAtop(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeDstIn: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeDstIn'].	result := self cCode: 'gezira_CompositeDstIn(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeDstOut: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeDstOut'].	result := self cCode: 'gezira_CompositeDstOut(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeDstOver: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeDstOver'].	result := self cCode: 'gezira_CompositeDstOver(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeExclusion: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeExclusion'].	result := self cCode: 'gezira_CompositeExclusion(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeHardLight: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeHardLight'].	result := self cCode: 'gezira_CompositeHardLight(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeInvert: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeInvert'].	result := self cCode: 'gezira_CompositeInvert(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeLighten: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeLighten'].	result := self cCode: 'gezira_CompositeLighten(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeMultiply: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeMultiply'].	result := self cCode: 'gezira_CompositeMultiply(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeOver: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeOver'].	result := self cCode: 'gezira_CompositeOver(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeOverlay: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeOverlay'].	result := self cCode: 'gezira_CompositeOverlay(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositePlus: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositePlus'].	result := self cCode: 'gezira_CompositePlus(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeScreen: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeScreen'].	result := self cCode: 'gezira_CompositeScreen(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeSoftLight: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeSoftLight'].	result := self cCode: 'gezira_CompositeSoftLight(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeSrc: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeSrc'].	result := self cCode: 'gezira_CompositeSrc(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeSrcAtop: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeSrcAtop'].	result := self cCode: 'gezira_CompositeSrcAtop(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeSrcIn: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeSrcIn'].	result := self cCode: 'gezira_CompositeSrcIn(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeSrcOut: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeSrcOut'].	result := self cCode: 'gezira_CompositeSrcOut(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeSubtract: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeSubtract'].	result := self cCode: 'gezira_CompositeSubtract(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelCompositeTextures: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result t1 t2 c |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #t1 type: 'nile_Process_t*'.	self var: #t2 type: 'nile_Process_t*'.	self var: #c type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeTextures'].	c := self popKernel.	t2 := self popKernel.	t1 := self popKernel.	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to CompositeTextures'].	result := self cCode: 'gezira_CompositeTextures(init, t1, t2, c)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelCompositeXor: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in CompositeXor'].	result := self cCode: 'gezira_CompositeXor(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelContrastiveOver: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result a |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #a type: 'float'.	argCount ~= 1		ifTrue: [^self fail: 'wrong argument count in ContrastiveOver'].	a := interpreterProxy floatValueOf: (argOops at: 0).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to ContrastiveOver'].	result := self cCode: 'gezira_ContrastiveOver(init, a)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelGaussianBlur11x1: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result f t |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #f type: 'float'.	self var: #t type: 'nile_Process_t*'.	argCount ~= 1		ifTrue: [^self fail: 'wrong argument count in GaussianBlur11x1'].	t := self popKernel.	f := interpreterProxy floatValueOf: (argOops at: 0).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to GaussianBlur11x1'].	result := self cCode: 'gezira_GaussianBlur11x1(init, f, t)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelGaussianBlur1x11: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result f t |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #f type: 'float'.	self var: #t type: 'nile_Process_t*'.	argCount ~= 1		ifTrue: [^self fail: 'wrong argument count in GaussianBlur1x11'].	t := self popKernel.	f := interpreterProxy floatValueOf: (argOops at: 0).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to GaussianBlur1x11'].	result := self cCode: 'gezira_GaussianBlur1x11(init, f, t)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelGaussianBlur1x21: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result f t |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #f type: 'float'.	self var: #t type: 'nile_Process_t*'.	argCount ~= 1		ifTrue: [^self fail: 'wrong argument count in GaussianBlur1x21'].	t := self popKernel.	f := interpreterProxy floatValueOf: (argOops at: 0).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to GaussianBlur1x21'].	result := self cCode: 'gezira_GaussianBlur1x21(init, f, t)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelGaussianBlur1x5: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result f t |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #f type: 'float'.	self var: #t type: 'nile_Process_t*'.	argCount ~= 1		ifTrue: [^self fail: 'wrong argument count in GaussianBlur1x5'].	t := self popKernel.	f := interpreterProxy floatValueOf: (argOops at: 0).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to GaussianBlur1x5'].	result := self cCode: 'gezira_GaussianBlur1x5(init, f, t)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelGaussianBlur21x1: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result f t |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #f type: 'float'.	self var: #t type: 'nile_Process_t*'.	argCount ~= 1		ifTrue: [^self fail: 'wrong argument count in GaussianBlur21x1'].	t := self popKernel.	f := interpreterProxy floatValueOf: (argOops at: 0).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to GaussianBlur21x1'].	result := self cCode: 'gezira_GaussianBlur21x1(init, f, t)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelGaussianBlur5x1: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result f t |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #f type: 'float'.	self var: #t type: 'nile_Process_t*'.	argCount ~= 1		ifTrue: [^self fail: 'wrong argument count in GaussianBlur5x1'].	t := self popKernel.	f := interpreterProxy floatValueOf: (argOops at: 0).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to GaussianBlur5x1'].	result := self cCode: 'gezira_GaussianBlur5x1(init, f, t)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelInverseOver: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result a |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #a type: 'float'.	argCount ~= 1		ifTrue: [^self fail: 'wrong argument count in InverseOver'].	a := interpreterProxy floatValueOf: (argOops at: 0).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to InverseOver'].	result := self cCode: 'gezira_InverseOver(init, a)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 11/18/2011 19:05'!kernelLinearGradient: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result sX sY eX eY |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #sX type: 'float'.	self var: #sY type: 'float'.	self var: #eX type: 'float'.	self var: #eY type: 'float'.	argCount ~= 4		ifTrue: [^self fail: 'wrong argument count in LinearGradient'].	sX := interpreterProxy floatValueOf: (argOops at: 0).	sY := interpreterProxy floatValueOf: (argOops at: 1).	eX := interpreterProxy floatValueOf: (argOops at: 2).	eY := interpreterProxy floatValueOf: (argOops at: 3).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to LinearGradient'].	result := self cCode: 'gezira_LinearGradient(init, sX, sY, eX, eY)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 9/22/2011 14:51'!kernelPadGradient: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in PadGradient'].	result := self cCode: 'gezira_PadGradient(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 9/22/2011 14:51'!kernelPadTexture: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result dX dY |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #dX type: 'float'.	self var: #dY type: 'float'.	argCount ~= 2		ifTrue: [^self fail: 'wrong argument count in PadTexture'].	dX := interpreterProxy floatValueOf: (argOops at: 0).	dY := interpreterProxy floatValueOf: (argOops at: 1).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to PadTexture'].	result := self cCode: 'gezira_PadTexture(init, dX, dY)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 9/22/2011 14:51'!kernelRadialGradient: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result cX cY r |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #cX type: 'float'.	self var: #cY type: 'float'.	self var: #r type: 'float'.	argCount ~= 3		ifTrue: [^self fail: 'wrong argument count in RadialGradient'].	cX := interpreterProxy floatValueOf: (argOops at: 0).	cY := interpreterProxy floatValueOf: (argOops at: 1).	r := interpreterProxy floatValueOf: (argOops at: 2).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to RadialGradient'].	result := self cCode: 'gezira_RadialGradient(init, cX, cY, r)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/8/2011 15:27'!kernelRasterize: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in Rasterize'].	result := self cCode: 'gezira_Rasterize(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 5/20/2011 18:01'!kernelRectangleSpans: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result minX minY maxX maxY |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #minX type: 'float'.	self var: #minY type: 'float'.	self var: #maxX type: 'float'.	self var: #maxY type: 'float'.	argCount ~= 4		ifTrue: [^self fail: 'wrong argument count in RectangleSpans'].	minX := interpreterProxy floatValueOf: (argOops at: 0).	minY := interpreterProxy floatValueOf: (argOops at: 1).	maxX := interpreterProxy floatValueOf: (argOops at: 2).	maxY := interpreterProxy floatValueOf: (argOops at: 3).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to RectangleSpans'].	result := self cCode: 'gezira_RectangleSpans(init, minX, minY, maxX, maxY)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 9/22/2011 14:51'!kernelReflectGradient: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in ReflectGradient'].	result := self cCode: 'gezira_ReflectGradient(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 9/22/2011 14:51'!kernelReflectTexture: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result dX dY |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #dX type: 'float'.	self var: #dY type: 'float'.	argCount ~= 2		ifTrue: [^self fail: 'wrong argument count in ReflectTexture'].	dX := interpreterProxy floatValueOf: (argOops at: 0).	dY := interpreterProxy floatValueOf: (argOops at: 1).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to ReflectTexture'].	result := self cCode: 'gezira_ReflectTexture(init, dX, dY)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 9/22/2011 14:51'!kernelRepeatGradient: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	argCount ~= 0		ifTrue: [^self fail: 'wrong argument count in RepeatGradient'].	result := self cCode: 'gezira_RepeatGradient(init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 9/22/2011 14:51'!kernelRepeatTexture: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result dX dY |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #dX type: 'float'.	self var: #dY type: 'float'.	argCount ~= 2		ifTrue: [^self fail: 'wrong argument count in RepeatTexture'].	dX := interpreterProxy floatValueOf: (argOops at: 0).	dY := interpreterProxy floatValueOf: (argOops at: 1).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to RepeatTexture'].	result := self cCode: 'gezira_RepeatTexture(init, dX, dY)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 5/31/2011 19:25'!kernelStrokeBezierPath: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result w l c |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #w type: 'float'.	self var: #l type: 'float'.	self var: #c type: 'float'.	argCount ~= 3		ifTrue: [^self fail: 'wrong argument count in StrokeBezierPath'].	w := interpreterProxy floatValueOf: (argOops at: 0).	l := interpreterProxy floatValueOf: (argOops at: 1).	c := interpreterProxy floatValueOf: (argOops at: 2).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to StrokeBezierPath'].	result := self cCode: 'gezira_StrokeBezierPath(init, w, l, c)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelTransformBeziers: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result mA mB mC mD mE mF |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #mA type: 'float'.	self var: #mB type: 'float'.	self var: #mC type: 'float'.	self var: #mD type: 'float'.	self var: #mE type: 'float'.	self var: #mF type: 'float'.	argCount ~= 6		ifTrue: [^self fail: 'wrong argument count in TransformBeziers'].	mA := interpreterProxy floatValueOf: (argOops at: 0).	mB := interpreterProxy floatValueOf: (argOops at: 1).	mC := interpreterProxy floatValueOf: (argOops at: 2).	mD := interpreterProxy floatValueOf: (argOops at: 3).	mE := interpreterProxy floatValueOf: (argOops at: 4).	mF := interpreterProxy floatValueOf: (argOops at: 5).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to TransformBeziers'].	result := self cCode: 'gezira_TransformBeziers(init, mA, mB, mC, mD, mE, mF)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelTransformPoints: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result mA mB mC mD mE mF |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #mA type: 'float'.	self var: #mB type: 'float'.	self var: #mC type: 'float'.	self var: #mD type: 'float'.	self var: #mE type: 'float'.	self var: #mF type: 'float'.	argCount ~= 6		ifTrue: [^self fail: 'wrong argument count in TransformPoints'].	mA := interpreterProxy floatValueOf: (argOops at: 0).	mB := interpreterProxy floatValueOf: (argOops at: 1).	mC := interpreterProxy floatValueOf: (argOops at: 2).	mD := interpreterProxy floatValueOf: (argOops at: 3).	mE := interpreterProxy floatValueOf: (argOops at: 4).	mF := interpreterProxy floatValueOf: (argOops at: 5).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to TransformPoints'].	result := self cCode: 'gezira_TransformPoints(init, mA, mB, mC, mD, mE, mF)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'generated' stamp: 'bf 3/14/2011 20:28'!kernelUniformColor: argOops size: argCount	"Automatically generated (see generatePluginKernels)"	| result cA cR cG cB |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #cA type: 'float'.	self var: #cR type: 'float'.	self var: #cG type: 'float'.	self var: #cB type: 'float'.	argCount ~= 4		ifTrue: [^self fail: 'wrong argument count in UniformColor'].	cA := interpreterProxy floatValueOf: (argOops at: 0).	cR := interpreterProxy floatValueOf: (argOops at: 1).	cG := interpreterProxy floatValueOf: (argOops at: 2).	cB := interpreterProxy floatValueOf: (argOops at: 3).	interpreterProxy failed ifTrue: [^self fail: 'wrong arguments to UniformColor'].	result := self cCode: 'gezira_UniformColor(init, cA, cR, cG, cB)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'commands' stamp: 'bf 11/18/2011 17:11'!executeCommand: commandArrayOop	"Command is an Array like #('Cmd' arg1 arg2). Dispatch to the actual commands"	| commandArray commandArraySize commandNameOop commandName commandNameSize |	self returnTypeC: 'void'.	self var: #commandName type: 'char*'.	self var: #commandArray type: 'sqInt*'.	commandArraySize := interpreterProxy slotSizeOf: commandArrayOop.	commandArraySize > 0		ifFalse: [^self fail: 'Empty command'].	commandArray := interpreterProxy firstIndexableField: commandArrayOop.	commandNameOop := interpreterProxy fetchPointer: 0 ofObject: commandArrayOop.	(interpreterProxy isBytes: commandNameOop)		ifFalse: [^self fail: 'Command name not a String'].	commandName := interpreterProxy firstIndexableField: commandNameOop.	commandNameSize := interpreterProxy slotSizeOf: commandNameOop.	(self string: 'Kernel' equals: commandName len: commandNameSize)		ifTrue: [^self executeKernel: commandArray+1 size: commandArraySize-1].	(self string: 'Pour' equals: commandName len: commandNameSize)		ifTrue: [^self executePour: commandArray+1 size: commandArraySize-1].	(self string: 'Sync' equals: commandName len: commandNameSize)		ifTrue: [^self executeSync: commandArray+1 size: commandArraySize-1].	self fail: 'Unknown command'.! !!GeziraBindingsMTPlugin methodsFor: 'commands' stamp: 'bf 8/10/2010 16:15'!executeKernel: argOops size: argCount	"A kernel command looks like #('KernelName' arg1 arg2). Dispatch on the name."	| kernelNameOop kernelName kernelNameSize |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #kernelName type: 'char*'.	argCount < 1		ifTrue: [^self fail: 'No kernel name given'].	kernelNameOop := argOops at: 0.	(interpreterProxy isBytes: kernelNameOop)		ifFalse: [^self fail: 'kernel name not a String'].	kernelName := interpreterProxy firstIndexableField: kernelNameOop.	kernelNameSize := interpreterProxy slotSizeOf: kernelNameOop.	self dispatchKernel: kernelName size: kernelNameSize arguments: argOops + 1 size: argCount - 1.! !!GeziraBindingsMTPlugin methodsFor: 'commands' stamp: 'bf 3/14/2011 20:27'!executePour: argOops size: argCount	"Pour command args are (vertices start end eos)"	| pipeline vertices start end eos |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #pipeline type: #'nile_Process_t*'.	self var: #vertices type: #'float*'.	argCount ~= 4		ifTrue: [^self fail: 'wrong argument count in Pour'].	pipeline := self topKernel.	vertices := interpreterProxy arrayValueOf: (argOops at: 0).	start := interpreterProxy checkedIntegerValueOf: (argOops at: 1).	end := interpreterProxy checkedIntegerValueOf: (argOops at: 2).	eos := interpreterProxy booleanValueOf: (argOops at: 3).	interpreterProxy failed ifTrue: [		^self fail: 'wrong arguments in Pour'].	self cCode: 'nile_Funnel_pour (pipeline, vertices + start - 1, end - start + 1, eos)'		inSmalltalk: [pipeline. vertices. start. end. eos].	eos ifTrue: [self popKernel].! !!GeziraBindingsMTPlugin methodsFor: 'commands' stamp: 'bf 7/20/2012 14:57'!executeSync: argOops size: argCount	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self cCode: 'nile_sync(init)'.	errorCode := self cCode: 'nile_status(init)'.	errorCode ~= (self cCode: 'NILE_STATUS_OK') ifTrue: [^self fail: 'sync failed'].	self reset.	wasSync := true.! !!GeziraBindingsMTPlugin methodsFor: 'commands' stamp: 'bf 5/20/2011 17:45'!kernelCapture: argOops size: argCount	"Argument is a FloatArray"	| arrayOop array n arraySize result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #array type: 'float*'.	self var: #n type: 'static int'.	argCount ~= 1		ifTrue: [^self fail: 'wrong kernel argument count in Capture'].	arrayOop := argOops at: 0.	array := interpreterProxy arrayValueOf:  arrayOop.	interpreterProxy failed ifTrue: [^self fail: 'invalid array'].	arraySize := interpreterProxy slotSizeOf: arrayOop.	n := 0.	result := self cCode: 'nile_Capture (init, array, &n, arraySize)'		inSmalltalk: [array. arraySize. n].	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'commands' stamp: 'bf 11/18/2011 17:41'!kernelCompositeUniformColorOverImageARGB32: argOops size: argCount	"Argument is a Form and 4 Floats for the color"	| result alpha red green blue image |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #image type: 'gezira_Image_t*'.	self var: #alpha type: 'float'.	self var: #red type: 'float'.	self var: #green type: 'float'.	self var: #blue type: 'float'.	argCount ~= 5		ifTrue: [^self fail: 'wrong kernel argument count in WriteToImageARGB32UniformColor'].	alpha := interpreterProxy floatValueOf: (argOops at: 0).	red := interpreterProxy floatValueOf: (argOops at: 1).	green := interpreterProxy floatValueOf: (argOops at: 2).	blue := interpreterProxy floatValueOf: (argOops at: 3).	interpreterProxy failed ifTrue: [^self fail: 'invalid color components in WriteToImageARGB32UniformColor'].	image := self imageFromForm: (argOops at: 4).	interpreterProxy failed ifTrue: [^nil].	result := self cCode: 'gezira_CompositeUniformColorOverImage_ARGB32 (init, image, alpha, red, green, blue)'		inSmalltalk: [alpha. red. green. blue. image].	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'commands' stamp: 'bf 3/22/2011 19:47'!kernelFunnel: argOops size: argCount	"No arguments"	| result |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #v type: 'nile_Process_t**'.	argCount ~= 0		ifTrue: [^self fail: 'Funnel takes no arguments'].	result := self cCode: 'nile_Funnel (init)'.	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'commands' stamp: 'bf 3/9/2011 10:31'!kernelPipeline: argOops size: argCount	"Argument is an integer, pops n kernels"	| result n v |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #v type: 'nile_Process_t**'.	argCount ~= 1		ifTrue: [^self fail: 'wrong kernel argument count in Pipeline'].	n := interpreterProxy checkedIntegerValueOf: (argOops at: 0).	v := self popKernels: n.	interpreterProxy failed ifTrue: [^nil].	result := self cCode: 'nile_Process_pipe_v (v, n)' inSmalltalk: [v. n].	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'commands' stamp: 'bf 11/18/2011 17:09'!kernelReadFromImageARGB32: argOops size: argCount	"Argument is a Form"	| result image |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #image type: 'gezira_Image_t*'.	argCount ~= 1		ifTrue: [^self fail: 'wrong kernel argument count in ReadFromImageARGB32'].	image := self imageFromForm: (argOops at: 0).	interpreterProxy failed ifTrue: [^nil].	result := self cCode: 'gezira_ReadFromImage_ARGB32 (init, image, 1)'		inSmalltalk: [image].	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'commands' stamp: 'bf 11/18/2011 17:13'!kernelWriteToImageARGB32: argOops size: argCount	"Argument is a Form"	| result image |	self returnTypeC: 'void'.	self var: #argOops type: 'sqInt*'.	self var: #result type: 'nile_Process_t*'.	self var: #image type: 'gezira_Image_t*'.	argCount ~= 1		ifTrue: [^self fail: 'wrong kernel argument count in WriteToImageARGB32'].	image := self imageFromForm: (argOops at: 0).	interpreterProxy failed ifTrue: [^nil].	result := self cCode: 'gezira_WriteToImage_ARGB32 (init, image)'		inSmalltalk: [image].	self pushKernel: result.! !!GeziraBindingsMTPlugin methodsFor: 'initialize-release' stamp: 'bf 11/18/2011 15:52'!initialiseModule	self export: true.	memSize := 0.	mem := nil.	threads := 0.	init := nil.	0 to: images sizeof / (images at: 0) sizeof - 1 do: [:i |		self cCode: 'images[i].pixels = NULL'].	self reset.	^true! !!GeziraBindingsMTPlugin methodsFor: 'initialize-release' stamp: 'bf 7/20/2012 14:55'!reset	| i |	stackP := 0.	errorMsg := nil.	errorItem := 0.	errorCode := self cCode: 'NILE_STATUS_OK'.	i := 0.	[i < (images sizeof / (images at: 0) sizeof)		and: [self cCode: 'images[i].pixels !!= NULL']	] whileTrue: [		self cCode: 'gezira_Image_done (&images[i])'.		self cCode: 'images[i].pixels = NULL'.		i:= i + 1].! !!GeziraBindingsMTPlugin methodsFor: 'initialize-release' stamp: 'bf 3/8/2011 15:51'!shutdownModule	self export: true.	mem isNil ifFalse: [		self cCode: 'free (nile_shutdown (init))'.		mem := nil].	^true! !!GeziraBindingsMTPlugin methodsFor: 'matrix primitives' stamp: 'yo 1/17/2011 20:00'!loadArgumentMatrix: matrix	"Load the argument matrix"	self returnTypeC:'float *'.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: matrix) and:[(interpreterProxy slotSizeOf: matrix) = 6]) 		ifFalse:[interpreterProxy primitiveFail.				^nil].	^self cCoerce: (interpreterProxy firstIndexableField: matrix) to:'float *'.! !!GeziraBindingsMTPlugin methodsFor: 'matrix primitives' stamp: 'yo 1/17/2011 19:59'!loadArgumentPoint: point	"Load the argument point into m23ArgX and m23ArgY"	| oop isInt |	interpreterProxy failed ifTrue:[^nil].	"Check class of point"	(interpreterProxy fetchClassOf: point) = (interpreterProxy classPoint) 		ifFalse:[^interpreterProxy primitiveFail].	"Load X value"	oop := interpreterProxy fetchPointer: 0 ofObject: point.	isInt := interpreterProxy isIntegerObject: oop.	(isInt or:[interpreterProxy isFloatObject: oop])		ifFalse:[^interpreterProxy primitiveFail].	isInt		ifTrue:[m23ArgX := interpreterProxy integerValueOf: oop]		ifFalse:[m23ArgX := interpreterProxy floatValueOf: oop].	"Load Y value"	oop := interpreterProxy fetchPointer: 1 ofObject: point.	isInt := interpreterProxy isIntegerObject: oop.	(isInt or:[interpreterProxy isFloatObject: oop])		ifFalse:[^interpreterProxy primitiveFail].	isInt		ifTrue:[m23ArgY := interpreterProxy integerValueOf: oop]		ifFalse:[m23ArgY := interpreterProxy floatValueOf: oop].! !!GeziraBindingsMTPlugin methodsFor: 'matrix primitives' stamp: 'yo 1/17/2011 21:53'!makePoint: x and: y	"Store the result of a previous operation."	| point xx yy |	self var: #x declareC: 'double x'.	self var: #y declareC: 'double y'.	point := interpreterProxy instantiateClass: interpreterProxy classPoint indexableSize: 2.	interpreterProxy pushRemappableOop: point.	xx := interpreterProxy floatObjectOf: x.	interpreterProxy pushRemappableOop: xx.	yy := interpreterProxy floatObjectOf: y.	xx := interpreterProxy popRemappableOop.	point := interpreterProxy popRemappableOop.	interpreterProxy storePointer: 0 ofObject: point withValue: xx.	interpreterProxy storePointer: 1 ofObject: point withValue: yy.	^ point.! !!GeziraBindingsMTPlugin methodsFor: 'matrix primitives' stamp: 'yo 1/17/2011 20:02'!matrix2x3TransformPoint: m	"Transform the pre-loaded argument point by the given matrix"	self var: #m type:'float *'.	m23ResultX := (m23ArgX * (m at: 0)) + (m23ArgY * (m at: 1)) + (m at: 2).	m23ResultY := (m23ArgX * (m at: 3)) + (m23ArgY * (m at: 4)) + (m at: 5).! !!GeziraBindingsMTPlugin methodsFor: 'matrix primitives' stamp: 'yo 1/17/2011 21:46'!primitiveTransformPoint: aPoint	| matrix |	self inline: false.	self primitive: 'primitiveTransformPoint' parameters: #(Oop).	self var: #matrix type:'float *'.	self loadArgumentPoint: aPoint.	matrix := self loadArgumentMatrix: (interpreterProxy stackObjectValue: 1).	interpreterProxy failed ifTrue:[^nil].	self matrix2x3TransformPoint: matrix.	^ self makePoint: m23ResultX and: m23ResultY.! !!GeziraBindingsMTPlugin methodsFor: 'matrix primitives' stamp: 'yo 1/17/2011 21:08'!primitiveTransformRect: srcOop into: dstOop	| matrix originX originY cornerX cornerY minX maxX minY maxY |	self export: true.	self inline: false.	self primitive: 'primitiveTransformRectInto' parameters: #(Oop Oop).	self var: #matrix type:'float *'.	self var: #originX type:'double '.	self var: #originY type:'double '.	self var: #cornerX type:'double '.	self var: #cornerY type:'double '.	self var: #minX type:'double '.	self var: #maxX type:'double '.	self var: #minY type:'double '.	self var: #maxY type:'double '.	matrix := self loadArgumentMatrix: (interpreterProxy stackObjectValue: 2).	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy fetchClassOf: srcOop) = (interpreterProxy fetchClassOf: dstOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: srcOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: srcOop) = 2		ifFalse:[^interpreterProxy primitiveFail].	"Load top-left point"	self loadArgumentPoint: (interpreterProxy fetchPointer: 0 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	originX := m23ArgX.	originY := m23ArgY.	self matrix2x3TransformPoint: matrix.	minX := maxX := m23ResultX.	minY := maxY := m23ResultY.	"Load bottom-right point"	self loadArgumentPoint:(interpreterProxy fetchPointer: 1 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	cornerX := m23ArgX.	cornerY := m23ArgY.	self matrix2x3TransformPoint: matrix.	minX := minX min: m23ResultX.	maxX := maxX max: m23ResultX.	minY := minY min: m23ResultY.	maxY := maxY max: m23ResultY.	"Load top-right point"	m23ArgX := cornerX.	m23ArgY := originY.	self matrix2x3TransformPoint: matrix.	minX := minX min: m23ResultX.	maxX := maxX max: m23ResultX.	minY := minY min: m23ResultY.	maxY := maxY max: m23ResultY.	"Load bottom-left point"	m23ArgX := originX.	m23ArgY := cornerY.	self matrix2x3TransformPoint: matrix.	minX := minX min: m23ResultX.	maxX := maxX max: m23ResultX.	minY := minY min: m23ResultY.	maxY := maxY max: m23ResultY.	^ self storeRectangle: dstOop x0: minX y0: minY x1: maxX y1: maxY.! !!GeziraBindingsMTPlugin methodsFor: 'matrix primitives' stamp: 'yo 1/17/2011 20:37'!storeRectangle: dstOop x0: x0 y0: y0 x1: x1 y1: y1	"Check, round and store the result of a rectangle operation"	| originOop cornerOop rectOop |	self var: #x0 type:'double '.	self var: #y0 type:'double '.	self var: #x1 type:'double '.	self var: #y1 type:'double '.	self var: #minX type:'double '.	self var: #maxX type:'double '.	self var: #minY type:'double '.	self var: #maxY type:'double '.	interpreterProxy pushRemappableOop: dstOop.	originOop := self makePoint: x0 and: y0.	interpreterProxy pushRemappableOop: originOop.	cornerOop := self makePoint: x1 and: y1.	originOop := interpreterProxy popRemappableOop.	rectOop := interpreterProxy popRemappableOop.	interpreterProxy storePointer: 0 ofObject: rectOop withValue: originOop.	interpreterProxy storePointer: 1 ofObject: rectOop withValue: cornerOop.	^rectOop! !!GeziraBindingsMTPlugin methodsFor: 'primitives' stamp: 'bf 6/16/2011 10:41'!primitiveErrorCode	self primitive: 'primitiveErrorCode'.	^errorCode asSmallIntegerObj 	! !!GeziraBindingsMTPlugin methodsFor: 'primitives' stamp: 'bf 3/14/2011 21:37'!primitiveErrorItem	self primitive: 'primitiveErrorItem'.	^errorItem asSmallIntegerObj 	! !!GeziraBindingsMTPlugin methodsFor: 'primitives' stamp: 'bf 3/14/2011 20:26'!primitiveErrorMessage	| msgLength msgOop msgPtr |	self primitive: 'primitiveErrorMessage'.	self var: #msgPtr type: #'char*'.	msgLength := 0.	errorMsg ~= nil ifTrue: [msgLength := errorMsg strlen].	msgOop := interpreterProxy instantiateClass: interpreterProxy classString indexableSize: msgLength.	msgLength > 0 ifTrue:[		msgPtr := interpreterProxy firstIndexableField: msgOop.		msgPtr str: errorMsg ncpy: msgLength].	^msgOop! !!GeziraBindingsMTPlugin methodsFor: 'primitives' stamp: 'bf 6/16/2011 11:07'!primitiveExecuteThreads: newThreads memory: newMemSize commands: allCommandsOop	"argument is an array of commands like #(#(Cmd1 args) #(Cmd2 args))"	| allCommands allCommandsSize eachCommandOop |	self primitive: 'primitiveExecuteThreadsMemCmds' parameters: #(SmallInteger SmallInteger Oop).	self var: #allCommands type: 'sqInt*'.	(interpreterProxy isArray: allCommandsOop)		ifFalse: [self fail: 'argument must be an Array'. ^nil].	(newMemSize > 0 and: [newThreads > 0])		ifFalse: [self fail: 'need memory and threads'. ^ nil].	newMemSize ~= memSize ifTrue: [		mem notNil ifTrue: [			self cCode: 'free (nile_shutdown (init))'].		threads := 0.		memSize := newMemSize.		mem := self malloc: memSize.		mem isNil ifTrue: [self fail: 'buffer allocation failed'. ^nil].	].	threads ~= newThreads ifTrue: [		threads ~= 0 ifTrue: [self cCode: 'nile_shutdown (init)'].		threads := newThreads.		init := self cCode: 'nile_startup (mem, memSize, threads)'.		init isNil ifTrue: [			threads := 0.			self fail: 'nile_startup failed'. ^nil]].	self reset.	allCommands := interpreterProxy firstIndexableField: allCommandsOop.	allCommandsSize := interpreterProxy slotSizeOf: allCommandsOop.	0 to: allCommandsSize - 1 do: [:i |		errorItem := i + 1.		eachCommandOop := allCommands at: i.		(interpreterProxy isArray: eachCommandOop)			ifFalse: [self fail: 'Command must be an Array'. ^nil].		wasSync := false.		self executeCommand: eachCommandOop.		interpreterProxy failed			ifTrue: [^nil].		self checkNileError.		interpreterProxy failed			ifTrue: [^nil]].	wasSync ifFalse: [		errorItem := errorItem + 1.		self executeSync: nil size: 0]! !!GeziraBindingsMTPlugin methodsFor: 'primitives' stamp: 'bf 3/10/2011 15:01'!primitiveNumberOfCores	"Answer number of (virtual) cores in this machine"	| numCPU |	self primitive: 'primitiveNumberOfCores'.	numCPU := self cCode: 'sysconf( _SC_NPROCESSORS_ONLN )'.	numCPU < 1 ifTrue: [self fail: 'could not determine number of cores'. ^nil].	^numCPU asSmallIntegerObj ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GeziraBindingsMTPlugin class	instanceVariableNames: ''!!GeziraBindingsMTPlugin class methodsFor: 'translation' stamp: 'bf 11/17/2011 19:29'!declareCVarsIn: cg	super declareCVarsIn: cg.	cg addHeaderFile: '"gezira.h"'.	cg addHeaderFile: '"gezira-image.h"'.	cg addHeaderFile: '<unistd.h>'.	cg var: #init type: #'nile_Process_t*'.	cg var: #mem type: #'char*'.	cg var: #stack declareC: #'nile_Process_t* stack[100]'.	cg var: #stackP type: #int.	cg var: #images declareC: #'gezira_Image_t images[100]'.	cg var: #errorMsg type: #'char*'.	cg var: #m23ResultX type: #double.	cg var: #m23ResultY type: #double.	cg var: #m23ArgX type: #double.	cg var: #m23ArgY type: #double! !!GeziraBindingsMTPlugin class methodsFor: 'translation' stamp: 'bf 6/15/2011 14:24'!moduleName	^'GeziraBindingsMT'! !!GeziraBindingsMTPlugin class methodsFor: 'translation' stamp: 'bf 3/17/2011 12:54'!moduleNameAndVersion	"Answer the receiver's module name and version info that is used for the plugin's C code. The default is to append the code generation date, but any useful text is ok (keep it short)"	^ self moduleName, ' ', self version, ' ', Date today asString! !!GeziraBindingsMTPlugin class methodsFor: 'translation' stamp: 'bf 3/17/2011 13:03'!version	| pkg wc version |	pkg := PackageOrganizer default packageOfClass: self.	wc := (MCPackage named: pkg packageName) workingCopy.	version := wc ancestors first name copyAfterLast: $-.	wc modified ifTrue: [version := version, '*'].	^version! !!GeziraBindingsMTPlugin class methodsFor: 'class initialization' stamp: 'bf 9/7/2010 16:48'!initialize	NileBufferSize := 5000000.! !GeziraBindingsMTPlugin initialize!